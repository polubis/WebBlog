--- 1 ---
My developerzy często narzekamy na technologie i podejścia w projektach. 
Czy jest możliwe dobranie ich tak,
aby projekt był przygotowany na zwariowane fluktuacje, 
które pojawią się ze strony biznesu?

No oczywiście, że nie :). Moim zdaniem jest jednak pewna baza technologii, podejść, które 
ograniczą przyszłe problemy, które pojawiają się w większości projektów. 

Dzisiaj zlokalizujemy popularne problemy dla platformy web i wybierzemy "dream stack", który je rozwiązuje, tak
abyś potem nie musiał się męczyć. 

--- 2 ---

Nie twórz projektu "ręcznie"

Po pierwsze to odradzam tworzenie projektu "ręcznie". 
Wiem, że może chcesz się popisać
znajomością "webpacka", ale nie każdy go zna. 
We wszystkich generatorach projektu "webpack"
jest ukryty za warstwą abstrakcji: jakiś json, plik JS. 

Dodatkowo jeżeli "webpack" będzie kiedyś wyparty przez coś innego to migracja może być trudniejsza.

Zatem co? Użyj generatora, który oszczędzi Ci czasu przy potencjalnej migracji oraz
sprawi, że raz na zawsze zapomnisz o tym diable jakim potrafi być "webpack" czy inny "pack".

// Widziałem przypadki w projektach, w których zespoły łamały się na przekomplikowanych konfiguracjach
webpacka i marnowały czas na zarządzanie tym kodem. Weź wytłumacz potem biznesowi, że potrzebujesz
kilku tygodni żeby zrobić coś co generator robi w sekunde - utrzymują je wyspecjalizowane zespoły
bądź community :0.

--- 3 ---

Jaki generator?

Zamiast wymieniać te których nie polecam, po prostu polece Ci konkretny tool, z którego będziesz 
zadowolony i wytłumacze dlaczego :0 - tak będzie szybciej.

Od jakiegoś czasu każdy projekt stawiam za pomocą "nx" od "nrwl". Jest ku temu kilka przesłanek.

- posiada potężne CLI.
- implementuje monorepo.
- pozwala kontrolować rozrost systemu i ułatwia skalowanie.
- pozwala tworzyc projekty backend/frontend.
- ma wspaniała dokumentacje.
- jest giga szybki.
- odrazu dorzuca eslint, prettiery i inne bajery.
- pozwala tworzyc projekty w Angular,React,Next,Node,Nest, ... i inne
- narzuca podejścia i architekturę czego React developerzy bardzo nie lubią :P.

Żeby udowodnić jak fajne jest to narzędzie tutaj macie link do przykładowego repozytorium, 
w którym jest aplikacja, i zestaw bibliotek.

// Nikt mi za to nie zapłacił, mówie serio. Po prostu fajny tool.

--- 4 ---

Czy dodać TypeScript

Odpowiedź jest ultra prosta - tak. Dzięki nx to będzie tylko wciśniecie klawisza.
Kto pracował w projektach TypeScript, ten wie jak dobrze napisany kod w tym wspaniałym języku
potrafi ułatwić codzienną prace.

Jest to tak naprawdę dodatkowy "quality gate" dla twojego kodu. W czasie rzeczywistym pokazuje
czy czegoś nie popsułeś, daje podpowiedzi oraz ułatwia zrozumienie kodu. Oczywiście TypeScript
potrafi być mega skomplikowany, dlatego korzystając z niego trzeba mieć łeb na karku.

// Jeżeli nie umiesz czegoś otypować i zajmie Ci to dzień - zostaw to na później, może z czasem ktoś codzienną
wesprze, w końcu to tylko coś co ma Ci ułatwić życie a nie utrudnić.

--- 5 --- 

Na miłość boską jakie style?

Widziałeś już pewnie zwykły css, scss, less, moduły css, bootstrap, styled-components, css-in-js, 
emotion, tailwind. Jest tego więcej, o wiele więcej. 

Naszczęscie nx wspiera i konfiguruje większość z wyżej wymienionych. Teraz dam Ci pewną rade. 
Najgorsze co można zrobić pisząc aplikacje to zasugerować sie tylko jedną metryką przy wyborze technologii.

Nie mówie, że masz teraz siedziec pare dni i się głowić oraz rozpisywać co powinieneś wykorzystać, ale
po prostu pamiętaj - "performance", "skalowalność", "łatwość wykorzystywania" - to tylko wierzchołek góry
lodowej - o wiele bardziej istotne sa wymagania biznesowe.

Jeżeli chcesz zapewnić wygodę developerom kosztem performance - użyj
styled components, które enkapsulują style oraz pozwalają na tworzenie biblioteki komponentów
w prosty sposób. Dodatkowo implementowanie motywów jest dziecinnie proste. 

Jeżeli masz pewność, że nie będzie motywów w aplikacji i chcesz mieć ultra piekne metryki w 
lighthouse - to wybierz tailwind. Owszem html wygląda okropnie, ale dzięki małym klasom, ktore
pobierzesz tylko raz oraz mechanizmowi, który czyści pliki wynikowe z nie używanego kodu - lepszego performance
nie uzyskasz. W dodatku praca z tailwind gdy się już go przyswoi jest bardzo szybka, plus narzuca on pewne konwencje i udostępnia komponenty.

Css, less, scss i ich moduły będą spoko jeżeli chcesz uzyskać to co wyżej, z lekko gorszym performance,
ale pamiętaj również że z obsługa motywów może byc ciężko. Gdy będziesz chciał stworzyć biblioteke
komponentów to musisz pamiętać o załączeniu styli do niej do projektu, który będzie z niej korzystał, a
developerzy tego nie lubią :).

Bootstrapy to tylko nakładka i w zależności od wersji to korzysta albo z css albo z js'a pod spodem.

Emotion jest bazą która pozwala Ci tworzyć komponenty nie tylko w React, ale posiada
nakładke dla niego, a styled-components używa Emotion i to tyle.

Css-in-js czyli jak generować pliki css, pisząc JS. Tego nie polecam, ze względu na to
że widoczny jest trend spatkowy dla tego toola oraz licznych postów na temat tego, żeby nie używać
tej technologii. Nie koniecznie jest zła, tylko community web jest podatne na trendy i to jest
raczej problemem w tym przypadku.

--- 6 ---

Reguły oraz quality gates

Zadbaj o to odrazu. Nie czekaj aż projekt urośnie... Będziesz miał dług technologiczny na samym starcie.

ESlint oraz prettier sa z defaultu dzięki nx. Możesz je dostosować do swoich potrzeb. Skonfiguruj
odrazu huskiego, aby uniknać możliwości pchnięcia commita bez formatowania - przynajmniej utrudnić 
oraz z błedami i warningami w eslint.

W dodatku dobrze jest odrazu ustalić limity rozmiarów paczek, tak aby widzieć i odpowiednio
zareagowac za pomocą code splitting w momencie gdy dany feature jest za duży.

--- 7 ---

Testowanie

Próg pokrycia testami ustaw odrazu... Testy musisz pisać jeżeli chcesz miec spokojna głowe.
Standardowo przyjmuje się 80%. Jeżeli ustawisz taki próg i będziesz pisać od pierwszej funkcjonalności
aby zaspokoić to pokrycie to uwierz mi, że nie jest to żaden problem. Po prostu rób to regularnie.

Pisz jak najwięcej unit testow bo są szybkie, wydzielaj kod tak aby to było możliwe. Napisz kilka
testów integracyjnych oraz test e2e. 

Dzięki nx - wszystko masz już skonfigurowane, testy e2e w cypress oraz unit, integracyjne za pomocą
jest.

--- 8 ---

Zaprojektuj architekture i ja udokumentuj

Rozpoczęcie pracy nad dowolną funkcjonalnościa bez jej przemyślenia to najgorsze co można zrobić.

Dobry programista różni się tym od przeciętnego, że myśli, a potem pisze, a nie na odwrót. Wbrew
pozorom nie jest to takie proste i wymaga lat praktyki, zmiany podejścia i pilnowania się w codziennej pracy.

Nie chodzi o to aby kod wykorzystywał wzroce projektowe, tylko należy skupić się na tym, aby
stworzony przez Ciebie kod był łatwy w utrzymaniu oraz się skalował.

To samo tyczy się architektury. Więc na początku zaplanuj warstwy, opisz za co odpowiada każda warstwa
,a następnie to udokumentuj. 

--- 9 --- 

Utworz przewodnik dla przyszlych developerow

Nowi developerzy w projekcie są jak dzieci we mgle. Mało który czyta dokumentacje, która mu dostarczysz. 
Jednak musi być jakiś przewodnik, który wdroży ich w praktyki w projekcie. 

Przykładowo zamiast dywagować w Code Review nad wykorzystanym podejściem, bo Piotrek skorzystał
z klas abstrakcyjnych, a wy piszecie w projekcie tylko funkcyjnie, to opisz podejścia w jakimś miejscu.

Dzięki temu zanim Piotr zmarnuje czas na implementacje czegoś co i tak nie przejdzie dalej, 
odrazu będzie wiedzial z jakiego podejscia skorzystać.

Tutaj masz link do przykładowego "CODE_GUIDE", który opisuje jak mogą wyglądać praktyki w projekcie.

Część z nich można weryfikować za pomocą ESLINT, ale niestety nie wszystkie :0.

--- 10 --- 

Podepnij CI & CD

Skąd wiedzieć czy napisana funkcjonalność przez developera nie psuje czegoś co było wcześniej,
nie niszczy formatowania w projekcie bądź wykorzystuje nie dozwolne praktyki, które zostaną odrzucone
przez ESLINT.

No sprawdzanie tego manualnie jest czasochłonne i wręcz niemożliwe. Zmuszanie developerów by
robili to przed wystawieniem pull requesta lub po pchnięciu commita tez.

Naszczęscie dziś mamy CI & CD, które możemy skonfigurować na wielu platformach - Github, Gitlab, AWS, Azure, ...etc.

--- 11 ---

Dodaj storybooka oraz chromatica

Według mnie storybook to gamechanger. Odkąd go poznałem zawsze zaczynam funkcjonalność od 
odpalenia go, przygotowania prezentacji, która działa niezależnie od domeny biznesowej aplikacji.
Oznacza to, że komponent który stworze może być użyty w dowolnej apce.

Storybook to dokumentacja, szybszy development komponentów oraz fajne narzędzie do debugowania. 
W dodatku gdy połączysz go z chromaticiem dostajesz narzędzie do testów wizualnych, które 
udostępnie mechanizmy akceptacji zmian.

Przykładowo możesz przy wystawieniu pull requesta do developa sprawdzić czy nie ma regresji
w wyglądzie twoich komponentów. Dzięki temu już nigdy nie będziesz musiał korzystać ze snapshot testów
i skupić się na testowaniu logiki komponentu, a nie tego jak wygląda i jest to dziecinnie proste.

--- 12 --- 

Lodash i RxJs

Jaki jest sens pisać coś raz jeszcze? Mam tu na myśli rzeczy takie jak funkcje do sortowania,
formatowanie, mapowanie czy grupowanie.

Lodash ma to wszystko. W dodatku jest tree-shakable. Oznacza to tyle, że zainstalowany i odpowiednio
zaimportowany dorzuca do bundle tylko i wyłącznie kod, który jest wykorzystany. Z doświadczenia wiem,
że utrzymywanie dodatkowego kodu jest upierdliwe, to czemu by tego nie uprościć korzystając
z czegoś tak pięknego jak Lodash - w dodatku z fajną dokumentacją i ogromnym uznaniem.

To samo tyczy się obsługi kodu asynchronicznego. Używanie promise, nakładki w postaci async/await - czyli też promise,
generatorów, czy oldschoolowych callbacków - ma ciągle ten sam problem. 

Pewnych operacji nie można anulować, nie można na nie zareagować. RxJs nazywany przez nie których
loadashem do programowania reaktywnego przemyca zestaw operatorów i pozwala reagować na zmiany
w aplikacji. 

W dodatku z React działa bardzo dobrze, a w Angular jest out of the box. Również warto wspomnieć,
że paradygmat programowania reaktywnego jest aktualnie dorzucany do prawie każdej nowej paczki
do state management i nie których frameworków czy bibliotek podobnych do React.

--- 13 --- 

Przemysl state management

Zapamiętaj jedną rzecz zanim dorzucisz Redux'a, Mobxa czy inne xy. Zarządzanie stanem aplikacji,
logiką biznesową nie powinno być scalone z frameworkiem, z którego korzystasz. 

Przykładowo jeżeli chcesz zaimplementować formularz krokowy z użyciem Reduxa. Pierwsze co zrobisz 
to stworzysz sobie reducer, akcje, i zaczniesz odczytywać przez selektory, a zmiany w storze
inicjowac dispatchowaniem akcji.

Jest to podejście powiedziałbym - książkowe. Jednak co w przypadku gdy Redux stanie się FO-PA?

No tu już jet problem. Miałem takie przypadki w swojej karierze, gdy developerzy zafascynowani 
jakąś technologią po przejściu kursu i nie zwerfyikowaniem jej w kontekście dziwact klienta, później
migrowali się z niej panicznie. 

Chodzi o to żeby zabezpieczyć się przez takim scenariuszem. Jeżeli już korzystac z Reduxa czy innego
to pomyśl nad wykorzystaniem fasad, które ułatwią później migracje. To tylko minuta bądź dwie 
jeżeli masz snipetty więcej, a później godziny, dnie, tygodnie oszczędzonej pracy i stresu :).

W dodatku sama logika zmiany stanu również może mieć fasadę, która będzie tworzyć nowy obiekt.

--- 14 --- 

Uzyc NextJS?

Pytanie brzmi czy SEO jest istotne? Czy zależy Ci na 100% wynikach w Lighthause i czy 
chcesz byc jak to mówia "blazingly fast". 

Aktualnie jak myśle - React to odrazu mam w głowie Next. Z prostych powodów.

- Łatwa obsługa tłumaczeń,
- Możliwość generowania stron statycznych w oparciu o dowolny source danych (plik md, baza danych),
- Wybór pomiędzy generowaniem stron, renderowaniem po stronie serwera oraz klienta,
- Regeneracja stron statycznych,
- Lepszy performance,
- CSR aktualnie to za mało - i sprawdza się w tylko konkretnych przypadkach (hermetyczna apka admina czy coś w podobie),
- Wspaniała dokumentacja - o wiele lepsza niż React :P.
- ...mógłbym tu wymieniać.
- łatwy deployment.

Ma też troche wad - nie jest to prosta apka single page czy static site więc wymaga
większej wiedzy. W dodatku deployment i integracja z chmurą potrafi być trudna, ale
jak zawsze coś za coś.

// Nikt mi za to nie zapłacił, serio... Next.js to kawał konkretnego dziada, który
// oferuje bardzo dużo możliwości.

--- 15 ---

Zadbaj o konmfort pracy innych, czyli snippety

Pliki z testami, z komponentami, dla storybooka powinny mieć snippety - dla każdego
wspólne w projekcie. Oszczędza to czas przy code review oraz generalnie skraca
czas pracy, klepania i redukuje ryzyko cieśni nadgarstka. 

Serio pomyśl o tym jak bardzo podziękuje Ci twoje ciało gdy zaczniesz z nich korzytać - oraz
pewnie koledzy z projektu. 

Tutaj kilka, które skonfigurowałem dla tego projektu.


--- Podsumowanie ---

Dobraaa. Zrobił się z tego potężny artykuł, ale jest to też potężny i poważny temat, którego
nie można lekceważyć. Myśle nad zrobieniem drugiej części, która dorzuci jeszcze kilka
bajerów, ale to z czasem :0.

Mam nadzieje, że troche Ci ułatwiłem życie w przyszłym projekcie i zanim skorzystać z moich
zaleceń - pamiętaj, że powinieneś mieć własne zdanie i chęć niezgodzenia się z częścią z nich.

Nigdy nie rób nic bez przemyślenia zwłaszcza w programowaniu, a słowo "it's good practice" traktuj
jako buzzword jeżeli jest powiedziane bez kontekstu i przykładów. 