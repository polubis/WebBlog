---
cdate: 2023-07-10
mdate: 2023-07-10
authorId: polubis
treviewerId: goteii
langs: ["en"]
lreviewerId: kzalewska
lang: pl
tags: patterns,facade,storage
stack: javascript,typescript,jest
description: Napiszemy wrapper, kt贸ry uatwi nam zarzdzanie local storage oraz session storage.
readTime: 6
seniorityLevel: advanced
title: Obsugujemy local storage oraz session storage
---

<Prelude label="Wstp">
  <M>
    <B>Local storage</B> i <B>session storage</B> to jedne z najczciej
    u偶ywanych mechanizm贸w do przechowywania danych w aplikacjach web. Pomijam
    ciasteczka , bo mam uczulenie na gluten.{" "}
  </M>
  <M>
    Dzi stworzymy mechanizm, kt贸ry ujednolici prac nad tymi szarlatanami,
    zapewni <B>type safety</B> i sprawi, 偶e odczyt i manipulacja stanie si
    prostrza!
  </M>
  <Hint hasBg>
    Je偶eli jeste leniwy i chcesz gotowy kod - mo偶esz go dosta w nastpujcym{" "}
    <A
      href="https://github.com/polubis/Dream-stack-for-React-dev/tree/article/working-with-local-storage-vs-session-storage-v1/system/libs/utils/src/lib/storage"
      outside
    >
      repozytorium
    </A>
    .
  </Hint>
</Prelude>

<Section>
  <XL>Dlaczego potrzebujemy wrappera na local/session storage?</XL>
  <M>
    Analizujc API <B>local/session</B> storage mo偶na zauwa偶y, 偶e ich metody s
    identyczne - maj tak sam sygnatur.{" "}
  </M>
  <Snippet>
    {`// "clear" czyci cay local storage.
localStorage.clear()
localStorage.removeItem('my-item')
// Dozwolony tylko "string" jako warto.
localStorage.setItem('my-item', 'value')
// Zwr贸cona warto to zawsze "string".
const lsValue = localStorage.getItem('my-item')
 
// "clear" czyci cay session storage.
sessionStorage.clear()
sessionStorage.removeItem('my-item')
// Dozwolony tylko "string" jako warto.
sessionStorage.setItem('my-item', 'true')
// Zwr贸cona warto to zawsze "string".
const sValue = sessionStorage.getItem('my-item')
`}
  </Snippet>
  <M>
    <B>Co rzuca si w oczy w pierwszym momencie?</B>
  </M>
  <List items="Klucz to 'string', Odczytana warto jest typu 'string', API s identyczne, Brak enkapsulacji" />
  <M>atwo zrobi liter贸wk...</M>
  <Snippet>{`const value = localStorage.getItem('liter贸,wka')`}</Snippet>
  <M>
    Dodatkowo mo偶emy przez pomyk uruchomi ten kod po stronie serwera, co nie
    ma szansy zadziaa -{" "}
    <B>obydwa API s dostpne tylko w rodowisku przegldarki</B>.
  </M>
  <Snippet>{`
// server.ts
// To jest kod uruchomiony po stronie serwera!
const value = localStorage.getItem('my-value')
// Szykuj si na wyjtek!
`}</Snippet>
  <M>
    Wiadomo bdu niekoniecznie mo偶e naprowadzi na przyczyn bdu. Jest to
    problem zwaszcza dla pocztkujcych <B>Frtasi贸w</B>.
  </M>
  <M>
    Nastpnym frykasem jest wykorzystywanie API <B>local/session</B> storage
    pomidzy r贸偶nymi plikami. Sp贸jrz na poni偶szy przykad:{" "}
  </M>
  <Snippet>{`
// plik1.ts
const user = localStorage.get('user')
// plik2.ts
const user = localStorage.get('user')
// I tak dalej...
`}</Snippet>
  <M>
    <B>A co z odczytem i zapisem?</B>
  </M>
  <M>
    Za ka偶dym razem musimy robi powtarzaln logik - parsowanie przy odczycie i
    zapisie.
  </M>
  <Snippet>
    {`
// @@@ Odczyt @@@
 
// To jest "string"! Trzeba go przeksztaci do "object".
const user = localStorage.get('user')
console.log(user.id) // undefined! 
console.log(JSON.parse(user.id)) // 1
 
// @@@ Zapis @@@
 
// To jest "obiekt"! Trzeba go przeksztaci do "string".
// Type error - wymaga "string".
localStorage.setItem('user', user)
// Teraz jest ok!
localStorage.setItem('user', JSON.stringify(user))
`}
  </Snippet>
  <M>
    Czas na ostatni frykas! A co z mockowaniem przy testowaniu? No, czeka nas ta
    sama duplikacja logiki i brak silnego typowania.
  </M>
  <Snippet>
    {` describe('Authorization works when: ', () => {
  afterEach(() => {
    localStorage.clear()
  })
 
  it('gets user from storage', () => {
    const user = { id: 1 }
    // Zn贸w powtarzamy "stringify" i jestemy nara偶eni na 
    // liter贸wki...
    localStorage.set('user', JSON.stringify(user))
 
    const result = getUserFromStorage()
 
    expect(result).toEqual(user)
  })
})
 `}
  </Snippet>
  <M>Jak widzisz jest tego sporo, a pominem jeszcze takie rzeczy jak:</M>
  <List items="A co jak potrzebujemy dodatkowej metody?, Brak enkapsulacji, Singleton na caej aplikacji - atwo popsu inn funkcjonalno, Mo偶na doprowadzi do kolizji - nadpisa warto ustawion w innej funkcjonalnoci" />
  <M>Musimy to naprawi!</M>
</Section>

<Section>
  <XL>Drobna inspiracja na pocztek</XL>
  <M>
    Pamitasz bibliotek <B>Axios</B>? Zapewne tak! Tworzymy w niej instancj
    obiektu, kt贸ry w oparciu o przekazan konfiguracj zwraca Ci konkretne,
    sp贸jne i wygodne w u偶yciu API. Chcemy uzyska taki sam efekt.
  </M>
  <M>
    W <B>Axios</B> robimy tak:{" "}
  </M>
  <Snippet>
    {`const blogAPI = axios.create({
  baseURL: getUrl(),
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json',
  },
  validateStatus: isOkStatus,
})
 
// Mamy metody, kt贸re maj dostp do przekazanej konfiguracji.
blogAPI.post()
blogAPI.get()`}
  </Snippet>
  <M>A nasza drobna biblioteczka zrobi tak:</M>
  <Snippet description="Tak bdzie wygldaa inicjalizacja">{`
import { storage } from 'storage'
 
interface AuthStorage {
  authorized: boolean
}
 
// Mo偶na przekaza "local/session" jako warto.
const authStorage = storage<AuthStorage>("session");
`}</Snippet>
  <M>Tu wywoanie metod: </M>
  <Snippet description="A tak bd wyglda nasze metody">{`
// Wyczyszcze tylko to co zostao ustawione przez metody 
// z "authStorage" i nic wicej!
authStorage.clear()
 
// Wyczyszcze tylko flag "authorized".
authStorage.remove('authorized')
 
// Pobierzemy wszystkie klucze.
const keys = authStorage.getKeys()
console.log(keys) // ['authorized']
 
// Dostaniemy warto boolean, a nie "true".
// Nie musimy ju偶 woa "JSON.parse".
authStorage.get('authorized')
console.log(authorized) // true/false
 
// Ustawimy warto "authorized" na true.
// Nie musimy u偶ywa "JSON.stringify".
authStorage.set('authorized', true)`}</Snippet>
  <M>
    Sp贸jrz na poni偶szy <B>gif</B> i zobacz jaka jest docelowa idea:
  </M>
  <Img
    src="https://raw.githubusercontent.com/polubis/Snippets/main/storage-gif.gif"
    border
    description="TypeScript ju偶 nas odpowiednio przypilnuje"
  />
</Section>

<Section>
  <XL>Modelujemy local/session storage i piszemy testy</XL>
  <M>
    Na pocztek stw贸rzmy sobie <B>string literal type</B>, w kt贸rym zdefiniujemy
    wspierane <B>storage</B> oraz dodamy szkielet funkcji <B>storage</B>.
  </M>
  <Snippet>
    {`
type StorageType = 'session' | 'local'
 
const storage = <T extends Record<string, any>>(
  type: StorageType = 'local'
) => {
 // Nasz kod bdzie tutaj!
}
`}
  </Snippet>
  <M>
    Teraz testy do implementacji, kt贸rej jeszcze nie ma. Testy bd czerwone,{" "}
    dop贸ki nie napiszemy kodu, kt贸ry sprawi, 偶e zaczn by zielone - skorzystamy
    z <B>TDD</B>.
  </M>
  <Hint hasBg>
    Je偶eli chcesz zrozumie, czym jest <B>test driven development</B>, chcesz
    zgbi tajniki testowania, to zapraszam do tego{" "}
    <A
      outside
      href="/articles/quick-wins/improving-code-that-was-not-written-by-us/"
    >
      artykuu
    </A>{" "}
    oraz nastpujcego{" "}
    <A outside href="/courses/react-testing-spellbook/">
      kursu
    </A>
    .
  </Hint>
  <Snippet description="W tym tecie sprawdzamy, czy otrzymalimy odpowiedni wyjtek w przypadku wykorzystania mechanizmu po stronie serwera">{`
import { storage } from '../storage'
 
describe('Storage can be used when: ', () => {
  it('throws an error if any storage is undefined', () => {
    // Zapisujemy oryginaln implementacj do zmiennych.
    const localStorage = global.localStorage
    const sessionStorage = global.sessionStorage
    // Usuwamy local/session storage z obiektu globalnego.
    delete (global as never)['localStorage']
    delete (global as never)['sessionStorage']
    // Local/session storage nie istniej wic nasz kod musi
    // rzuci wyjtek.
    expect(() => storage().get('key')).toThrow()
    expect(() => storage('session').get('key')).toThrow()
    // Przywracamy oryginaln implementacj, aby nie wpyn
    // na inne testy.
    global.localStorage = localStorage
    global.sessionStorage = sessionStorage
  })
  
  // Pozostae testy tutaj!
})
`}</Snippet>
  <Snippet description="Tu sprawdzamy, czy mechanizm odczytu kluczy dziaa prawidowo">
    {`it('picks keys from local storage or session storage', () => {
  const ls = storage<UserData>()
  const ss = storage<UserData>('session')
 
  ls.set('id', 1)
  ss.set('id', 1)
  ss.set('name', 'piotr')
 
  expect(ls.getKeys()).toEqual(['id']);
  expect(ss.getKeys()).toEqual(['id', 'name'])
})`}
  </Snippet>
  <Snippet description="Testowana metoda ma za zadanie ustawi kilka wartoci">{`
it('allows to set several values', () => {
  const ls = storage<UserData>()
 
  ls.patch({ id: 1 })
 
  expect(ls.getKeys()).toEqual(['id'])
  expect(ls.get('id')).toBe(1)
  expect(ls.get('name')).toBe(null)
})`}</Snippet>
  <Snippet description="Sprawdzamy, czy zwracane s tylko wartoci, kt贸re zostay ustawione">{`
it('allows to get all values', () => {
  const ls = storage<UserData>()
 
  ls.patch({ id: 1 })
 
  expect(ls.getAll()).toEqual({ id: 1 })
 
  ls.patch({ id: 1, name: 'piotr' })
 
  expect(ls.getAll()).toEqual({ id: 1, name: 'piotr' })
})`}</Snippet>
  <M>
    No i na sam koniec test, kt贸ry weryfikuje dziaanie kilku metod wywoywanych
    po sobie - tak jak bdzie si to odbywa w rzeczywistoci.
  </M>
  <Snippet description="W tym tecie sprawdzamy, jak zachowuje si nasz mechanizm i symulujemy prawdziwy scenariusz u偶ycia">{`
it('allows to work with storage', () => {
  const specificStorage = storage<UserData>()
 
  specificStorage.set('id', 0)
 
  expect(specificStorage.get('id')).toBe(0)
  expect(specificStorage.getKeys()).toEqual(['id'] as (keyof UserData)[])
 
  specificStorage.set('name', 'Pablo')
  specificStorage.remove('name')
 
  expect(specificStorage.getKeys()).toEqual(['id'] as (keyof UserData)[])
  expect(specificStorage.get('id')).toBe(0)
 
  specificStorage.clear()
 
  expect(specificStorage.getKeys()).toEqual([])
  expect(specificStorage.get('id')).toBe(null)
  expect(specificStorage.get('name')).toBe(null)
})`}</Snippet>
</Section>

<Section>
<XL>Czas na implementacj - czyli sprawiamy, 偶e nasze testy bd zielone</XL>
<M>No dobra, mamy modele, testy i wiemy, jak nasze API bdzie wyglda/dziaa - teraz czas na implementacj, czyli to, co Frtasie, tacy jak my, kochaj najbardziej. </M>
<M>Zaczniemy od funkcji, kt贸ra rzuci wyjtek z odpowiednim komunikatem, je偶eli <B>local/session</B> storage nie bdzie zdefiniowane w obiekcie globalnym - przykadowo uruchomilimy nasz funkcj po stronie serwera.</M>
<Snippet added={[[1,17]]}>
{`
import type { StorageType } from './defs'
 
const getStorage = (type: StorageType): Storage => {
  const storage = type === 'local' ? localStorage : sessionStorage;
  
  if (!storage) {
    throw Error(\`
        Cannot find local storage and session storage.
  
        It may be caused because: 
            - both are unsupported,
            - you're using this util on a server (during SSR or SSG).
    \`);
  }
  
  return storage
}
 
const storage = <T extends Record<string, any>>(
  type: StorageType = 'local'
) => {
// Tu cigle nic nie ma!
}`}
</Snippet>
<M>Nastpnie dodamy implementacj metody do odczytu pojedynczej wartoci: <B>get</B>. Zwr贸 uwag na rzutowanie, kt贸re jest niezbdne - metoda <B>JSON.parse</B> nie pozwala na przekazanie generycznego parametru.</M>
<Snippet added={[[6,19], [22,22]]}>{`
// "T extends Record<string, any>" gwarantuje to, 偶e przekazany typ
// generyczny musi by obiektem.
const storage = <T extends Record<string, any>>(
  type: StorageType = 'local'
) => {
  // Tu bdziemy przechowywa dodane klucze.
  let keys: (keyof T)[] = []; 
  
  const get = <K extends keyof T>(key: K): T[K] | null => {
    // Pobieramy warto ze "storage", wyjtek zostanie rzucony je偶eli
    // wywoamy "get" po stronie serwera.
    const value = getStorage(type).getItem(key.toString())
 
    if (value === null) {
      return null
    }
 
    return JSON.parse(value) as T[K]
  }
 
  return {
    get,
  }
}
`}</Snippet>
<M>Czas na <B>getAll</B>, kt贸ra ma za zadanie zwr贸ci wszystkie ustawione wartoci. Zwr贸 uwag na <B>Record</B> i jego "dziwne" typowanie. Chcemy, aby zwr贸cony obiekt mia takie same klucze jak przekazany interfejs oraz odpowiadajce im wartoci.</M>
<Snippet added={[[1,17], [21,21]]}>
{`  
// Zwr贸cony obiekt musi mie klucz przekazanego
// typu generycznego oraz warto znajdujc si pod tym kluczem.
const getAll = (): Record<keyof T, T[keyof T] | null> => {
  const allStorageItems = keys.reduce<T>((acc, key) => {
    // Korzystamy z wczeniej zaimplementowanej funkcji "get".
    const value = get(key)
 
    if (value === null) return acc
    // Tworzymy obiekt.
    return {
      ...acc,
      [key]: value,
    };
  }, {} as T)
 
  return allStorageItems
};
 
return {
  get,
  getAll
}
`}
</Snippet>

<M>
  W tym momencie mamy dwa testy, kt贸re s zielone. Oznacza to, 偶e rzucanie
  wyjtk贸w i odczyt pojedynczej wartoci oraz wielu wartoci dziaa prawidowo.
</M>

<List items="throws an error if any storage is undefined 锔, allows to get all values 锔" />

<M>
  Teraz czas na <B>getKeys</B>. Tu niespodzianki nie ma. Po prostu zwracamy
  warto <B>keys</B>, do kt贸rej mamy dostp dziki <B>domkniciu (closure)</B>.
</M>

<Snippet
  added={[
    [1, 3],
    [8, 8],
  ]}
>
  {`  const getKeys = (): (keyof T)[] => {
  return keys;
};
   
return {
  get,
  getAll,
  getKeys 
}`}
</Snippet>

<M>
  Dlaczego jest to funkcja, a nie po prostu <B>keys: keys</B>. Musi to by
  funkcja, kt贸ra odczyta "najnowsze" wartoci. Je偶eli byaby to zmienna - to
  warto bya by zawsze taka sama - pocztkowo ustawionych kluczy (pusta
  tablica).
</M>

<M>Po tej zmianie kolejny test staje si zielony.</M>
<List items="picks keys from local storage or session storage 锔" />

<M>
  Teraz czas na ostatnie cztery metody: <B>remove</B>, <B>set</B>, <B>patch</B>{" "}
  oraz <B>clear</B>.{" "}
</M>

<Snippet
  added={[
    [1, 4],
    [6, 9],
    [11, 13],
    [15, 19],
    [23, 26],
  ]}
>
  {`const remove = <K extends keyof T>(key: K): void => {
  getStorage(type).removeItem(key.toString())
  keys = keys.filter((currKey) => currKey !== key)
};
 
const set = <K extends keyof T>(key: K, value: T[K]): void => {
  getStorage(type).setItem(key as string, JSON.stringify(value))
  !keys.includes(key) && keys.push(key)
}
 
const clear = (): void => {
  keys.forEach(remove)
}
 
const patch = (obj: Partial<T>): void => {
  Object.entries(obj).forEach(([key, value]) => {
    if (value !== undefined) set(key, value)
  })
}
 
return {
  getKeys,
  remove,
  set,
  patch,
  clear,
}
`}
</Snippet>

<M>W <B>remove</B> usuwamy warto z wybranego <B>local/session</B> storage, a nastpnie pozbywamy si przekazanego klucza z tablicy.</M>
<M>W <B>set</B> ustawiamy warto oraz dodajemy klucz. Jednoczenie sprawdzamy, czy klucz ju偶 istnieje. Je偶eli tak jest, to nie dodajemy tego samego - po co nam duplikaty?</M>
<M>W <B>clear</B> czycimy wszystko, co zostao kiedykolwiek ustawione - nie cae <B>local/session</B> storage - to mogoby wpyn na negatywnie na inne funkcjonalnoci.</M>
<M>W <B>patch</B> dodajemy tyle wartoci, ile przekazalimy kluczy w obiekcie. Jednoczenie sprawdzamy, czy przekazana warto nie jest przypadkiem <B>undefined</B> - to spowoduje wyjtek w <B>JSON.parse</B> przy pr贸bie odczytu. Dlatego pomijamy takie wartoci.</M>
<M>Po tych wszystkich zmianach w kodzie nasze testy s zielone jak <B>Shrek</B>.</M>
</Section>

<Section>
  <XL>Skoczony kod</XL>
  <M>
    W{" "}
    <A
      outside
      href="https://github.com/polubis/Dream-stack-for-React-dev/tree/article/working-with-local-storage-vs-session-storage-v1/system/libs/utils/src/lib/storage"
    >
      tym repozytorium
    </A>{" "}
    znajdziesz skoczone rozwizanie.
  </M>
</Section>

<Summary label="Podsumowanie">
  <M>Jeszcze raz na spokojnie co udao nam si osign : </M>
  <List items="Mamy developer friendly wyjtki, Zarzdzanie local/session storage jest moduowe, Mamy type-safety i ochrone przed liter贸wkami, Nie ma potrzeby zapamitywa kluczy w zmiennych, atwo mo偶emy dodawa nowe metody i rozszerza rozwizanie, Rozwizanie mo偶e by wykorzystywane do mockowania wartoci r贸wnie偶 w testach, Sp贸jne API, Mniejsze ryzyko kolizji lub nadpisania wartoci w innej funkcjonalnoci" />
  <M>
    Pod{" "}
    <A
      outside
      href="https://greenonsoftware.com/snippet-creator/?id=175b6b00-2b87-4c67-8800-6046f141dca9/"
    >
      tym adresem
    </A>{" "}
    znajdziesz animowany kod, kt贸ry poprowadzi Ci przez proces implementacji.
    Mo偶esz si nim pobawi, zaproponowa zmiany.
  </M>
  <M>
    Warto wspomnie, 偶e wprowadzanie abstrakcji takiej jak ta, nie zawsze ma
    sens. W tym przypadku jest to u偶yteczne, ale warto przeprowadzi por贸wnanie
    po zakoczonej pracy, jaki jest zysk i rezultat. Mo偶e nie byo to potrzebne?
  </M>
  <M>Wedug mnie nie jest to niezbdne, ale uatwia 偶ycie.</M>
  <M>
    Je偶eli si podobao, to pamitaj odwiedzi nas na{" "}
    <A
      href="https://www.linkedin.com/in/adrian-po%C5%82ubi%C5%84ski-281ab2172/"
      outside
    >
      Linkedin
    </A>
    , gdzie regularnie wrzucamy content z programowania.
  </M>
</Summary>
