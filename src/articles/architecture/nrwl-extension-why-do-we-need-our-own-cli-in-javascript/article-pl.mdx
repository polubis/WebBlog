---
cdate: 2023-07-24
mdate: 2023-07-24
authorId: polubis
treviewerId: kwozniak
lreviewerId: kzalewska
tags: testing,improvements,quality
langs: ["en"]
lang: pl
stack: cypress,javascript,typescript
description: Sprawdzimy wszystkie popularne podejÅ›cia, ktÃ³re znacznie uÅ‚atwiajÄ… utrzymywanie oraz skalowanie selektorÃ³w dla testÃ³w e2e.
readTime: 4
seniorityLevel: intermediate
title: Selektory w testach e2e i ich efektywne utrzymywanie
---

<Prelude label="NRWL Extension - Po co jest nam potrzebne wÅ‚asne CLI w JavaScript?">
  <Image
    src="https://github.com/WojtG/article-assets/blob/main/NRWL%20Extension/imgs/header_img.png?raw=true"
    description="CLI"
  />
  <M>
    ProgramiÅ›ci zazwyczaj uczÄ… siÄ™ poleceÅ„ do wielu CLI. Prawie kaÅ¼da
    technologia dostarcza CLI po to Å¼eby deweloper mÃ³gÅ‚ zautomatyzowaÄ‡ swojÄ…
    pracÄ™ poprzez gotowe mechanizmy do generowania kodu, budowania kodu,
    pobieranie zaleÅ¼noÅ›ci, tworzenie projektÃ³w z szablonu. CLI do danej
    technologii pozwala teÅ¼ na Å‚atwiejsze przygotowywanie procesÃ³w CI. Jednak
    takie narzÄ™dzie nie musi byÄ‡ tylko powiÄ…zane z danÄ… technologiÄ…, ale teÅ¼ z
    danym zespoÅ‚em programistÃ³w, czy konkretnym projektem. Jakie to ma zalety,
    po co to robiÄ‡? Ten artykuÅ‚ postara siÄ™ odpowiedzieÄ‡ na te pytanie.
  </M>
</Prelude>

<Section>
  <XL>A wiÄ™c po co?</XL>
  <M>
    Tak jak wspomniaÅ‚em wyÅ¼ej CLI sÄ… tworzone po to Å¼eby zautomatyzowaÄ‡ pracÄ™ z
    danÄ… technologiÄ… poprzez wykonywanie okreÅ›lonych zadaÅ„ z poziomu konsoli.
    Tylko, Å¼e podczas prac deweloperskich zadaÅ„ do automatyzacji jest o wiele
    wiÄ™cej, niÅ¼ tylko te powiÄ…zane z danÄ… technologiÄ…, ale teÅ¼ i z danÄ…
    organizacjÄ…, zespoÅ‚em, czy projektem. GÅ‚Ã³wne zalety tworzenia CLI wewnÄ…trz
    organizacji/projektu:
  </M>
  <M>
    â›½ <B>EfektywnoÅ›Ä‡</B>: CLI pozwala na wykonywanie wielu zadaÅ„ za pomocÄ…
    jednego polecenia lub skryptu, co moÅ¼e znacznie przyspieszyÄ‡ pracÄ™. Ponadto,
    CLI umoÅ¼liwia szybkie i Å‚atwe wykonanie zadaÅ„, ktÃ³re czÄ™sto powtarzajÄ… siÄ™,
    co pozwala zaoszczÄ™dziÄ‡ czas,
  </M>
  <M>
    <B>ğŸ¡ PowtarzalnoÅ›Ä‡</B>: CLI umoÅ¼liwia dokÅ‚adne powtÃ³rzenie procesu bez
    potrzeby rÄ™cznego wykonywania kaÅ¼dego kroku. DziÄ™ki temu, Å¼e wszystkie kroki
    sÄ… zapisane w jednym skrypcie, moÅ¼na Å‚atwo wykonywaÄ‡ tÄ™ samÄ… sekwencjÄ™
    dziaÅ‚aÅ„ wielokrotnie,
  </M>
  <M>
    <B>ğŸ”€ WspÃ³Å‚dzielenie</B>: CLI moÅ¼na udostÄ™pniÄ‡ innym czÅ‚onkom zespoÅ‚u,
    dziÄ™ki czemu wszyscy majÄ… dostÄ™p do tych samych narzÄ™dzi i procedur. DziÄ™ki
    temu moÅ¼na zwiÄ™kszyÄ‡ spÃ³jnoÅ›Ä‡ pracy zespoÅ‚owej i uniknÄ…Ä‡ bÅ‚Ä™dÃ³w wynikajÄ…cych
    z rÃ³Å¼nic w uÅ¼ywanych narzÄ™dziach,
  </M>
  <M>
    <B>ğŸ—ï¸ Automatyzacja</B>: CLI pozwala na automatyzacjÄ™ wielu zadaÅ„, co moÅ¼e
    znacznie przyspieszyÄ‡ proces wytwarzania oprogramowania. MoÅ¼na np. uÅ¼yÄ‡ CLI
    do budowania, testowania i wdraÅ¼ania aplikacji,
  </M>
  <M>
    <B>ğŸš SkalowalnoÅ›Ä‡</B>: CLI pozwala na Å‚atwe skalowanie procesÃ³w wytwarzania
    oprogramowania, co moÅ¼e byÄ‡ szczegÃ³lnie waÅ¼ne dla duÅ¼ych projektÃ³w. DziÄ™ki
    CLI moÅ¼na np. Å‚atwo uruchamiaÄ‡ wiele serwerÃ³w jednoczeÅ›nie.
  </M>
  <M>
    Niestandardowe, wÅ‚asne CLI tworzy tak naprawdÄ™ poziom abstrakcji, nad
    zewnÄ™trznymi technologiami, procesami w firmie, oraz w zespole. Taka
    abstrakcja zmniejsza poziom zaleÅ¼noÅ›ci, a co za tym idzie uÅ‚atwia wdroÅ¼enie
    nowych programistÃ³w, standaryzacjÄ™ procesÃ³w w zespole, czy ich
    automatyzacjÄ™.
  </M>
</Section>
<Section>
  <XL>WÅ‚asne CLI w projekcie NRWL Extension</XL>
  <M>
    NRWL Extension (NX) jest to narzÄ™dzie pozwalajÄ…ce na tworzenie monorepo dla
    projektÃ³w JS. Do projektÃ³w moÅ¼na dodawaÄ‡ rÃ³Å¼ne technologie poprzez pluginy.
    Jednym z takich pluginÃ³w jest plugin pozwalajÄ…cy tak naprawdÄ™ na tworzenie
    wÅ‚asnych pluginÃ³w. W ramach takiego bytu moÅ¼emy zarÃ³wno generowaÄ‡ kod, jak i
    wykonywaÄ‡ coÅ› na kodzie (budowaÄ‡, testowaÄ‡, formatowaÄ‡ itd.). KaÅ¼de z tych
    zadaÅ„ jest uruchamiane w Å›rodowisku Node.JS co za tym idzie moÅ¼emy je
    caÅ‚kowicie oprogramowaÄ‡ tak jak kaÅ¼dÄ… funkcjonalnoÅ›Ä‡ w projekcie. PÃ³Åºniej
    kaÅ¼de z tych zadaÅ„ moÅ¼emy uruchomiÄ‡ zarÃ³wno z poziomu UI poprzez NX Console,
    ale teÅ¼ i z poziomu terminala, co za tym idzie tworzymy tak naprawdÄ™ CLI w
    ramach projektu.
  </M>
  <M>
    <B>Tworzenie wlasnego pluginu</B>
  </M>
  <M>Schemat wykonywania komendy</M>
  <M>
    W pierwszej kolejnoÅ›ci jak to byÅ‚o wspomniane wyÅ¼ej naleÅ¼y zainstalowaÄ‡
    plugin do tworzenia pluginÃ³w:
  </M>
  <Code mode="static" lang="javascript">
    {`npm install
    @nrwl/nx-plugin@latestpet`}
  </Code>
  <M>i wygenerowaÄ‡ kod pluginu poleceniem:</M>
  <Code mode="static" lang="javascript">
    {`nx g @nrwl/nx-plugin:plugin
    [my-plugin]`}
  </Code>
  <L>
    <Li>
      <B>my-plugin </B> - nazwa pluginu
    </Li>
  </L>
  <M>
    <B>Task Executors - Wykonywanie zadaÅ„ na kodzie projektu</B>
  </M>
  <M>Schemat wykonywania komendy:</M>
  <Code mode="static" lang="javascript">
    {`nx run [project] [command] `}
  </Code>
  <M>lub</M>
  <Code mode="static" lang="javascript">
    {`nx [command] [project]`}
  </Code>
  <L>
    <Li>
      <B>project</B> - wybieramy jeden z projektÃ³w w ramach monorepo,
    </Li>
    <Li>
      <B>command</B> - wybieramy komendÄ™ przygotowanÄ… przez nas w Node.JS, ktÃ³rÄ…
      chcemy wykonaÄ‡
    </Li>
  </L>
  <M>
    MoÅ¼emy teÅ¼ przekazaÄ‡ specyficznÄ… konfiguracjÄ™ dla komendy (np. produkcyjnÄ…,
    lub testowÄ…)
  </M>
  <Code mode="static" lang="javascript">
    {`nx [command] [project]
    --configuration=[configuration]`}
  </Code>
  <M>OczywiÅ›cie moÅ¼emy teÅ¼ przekazaÄ‡ inne parametry do takiego zadania:</M>
  <Code mode="static" lang="javascript">
    {`nx [command] [project]
    --[optionNameInCamelCase]=[value]`}
  </Code>
  <L>
    <Li>
      <B>optionNameInCamelCase</B>- klucz parametru,
    </Li>
    <Li>
      <B>value</B> - wartoÅ›Ä‡ parametru
    </Li>
  </L>
  <M>
    <B>Jak stworzyÄ‡ wÅ‚asny executor?</B>
  </M>
  <M>NaleÅ¼y wykonaÄ‡ polecenie:</M>
  <Code mode="static" lang="javascript">
    {`nx generate
    @nrwl/nx-plugin:executor [check]
    --project=[my-plugin]`}
  </Code>
  <L>
    <Li>
      <B>my-plugin</B>- nazwa wczeÅ›niej utworzonego pluginu,
    </Li>
    <Li>
      <B>check</B>- nazwa zadania
    </Li>
  </L>
  <M>Kod ktÃ³ry siÄ™ wykona stworzy nastÄ™pujÄ…cÄ… strukturÄ™ plikÃ³w:</M>
  <Image
    src="https://github.com/WojtG/article-assets/blob/main/NRWL%20Extension/imgs/img2.png?raw=true"
    description="Struktura plikÃ³w"
  />
  <M>
    AnalizujÄ…c tÄ… strukturÄ™ gÅ‚Ã³wnym plikiem przechowujÄ…cym schemat executora na
    potrzeby konfiguracji jest schama.json. WyglÄ…da tak:
  </M>
  <Code mode="static" lang="json">
    {`{
    "$schema":
    "http://json-schema.org/schema",
    "type": "object",
    "properties": {
    "textToCheck": {
    "type": "string",
    "description": "Text To check"
    }
    }
    }
    `}
  </Code>
  <M>
    Przechowuje on gÅ‚Ã³wnie opis parametrÃ³w wywoÅ‚ywanego zadania. Parametry mogÄ…
    byÄ‡ rÃ³Å¼nego typu, mogÄ… byÄ‡ wymagane, lub nie, oraz mogÄ… teÅ¼ mieÄ‡ opcje do
    wyboru.
  </M>
  <M>Sama logika egzekutora znajduje siÄ™ w pliku executor.ts:</M>
  <Code
    mode="dynamic"
    lang="typescript"
    src="https://raw.githubusercontent.com/WojtG/article-assets/main/NRWL%20Extension/script.ts?token=GHSAT0AAAAAACIWZ2RV6DOK5VWC2H4U3SQQZKSBWRA"
    linesCount={15}
  />
  <M>
    Implementacja executora musi eksportowaÄ‡ funkcjÄ™, ktÃ³ra zwrÃ³ciÄ‡ obiekt{" "}
    <B>success: boolean</B>. Gdzie success powinno zwrÃ³ciÄ‡ informacjÄ™, czy
    poprawnie zadanie zostaÅ‚o wykonane. Dodatkowo jako pierwszy parametr wchodzÄ…
    opcje przekazane podczas wywoÅ‚ania, a drugi parametr to kontekst wywoÅ‚ania,
    ktÃ³ry miÄ™dzy innymi przekazuje informacje w jakim projekcie zostaÅ‚o wykonane
    zadanie.
  </M>
  <M>
    Ostatnim krokiem jest przypisanie zadania do konkretnego projektu. Robi to
    siÄ™ w pliku project.json danego projektu w sekcji target:
  </M>
  <Code
    mode="dynamic"
    lang="json"
    src="https://raw.githubusercontent.com/WojtG/article-assets/main/NRWL%20Extension/snippet.json?token=GHSAT0AAAAAACIWZ2RV5KW6WLKFCNPN5XBGZKSB2FQ"
    linesCount={20}
  />
  <M>A samo wywoÅ‚anie wyglÄ…da nastÄ™pujÄ…co:</M>
  <Code mode="static" lang="javascript">
    {`nx run [my-project]:[check]`}
  </Code>
  <L>
    <Li>
      <B>my-project</B>- nazwa projektu,
    </Li>
    <Li>
      <B>check</B> - nazwa zadania
    </Li>
  </L>
  <M>
    <B>Code Generators - Generowanie kodu projektu</B>
  </M>
  <M>
    Generatory dostarczajÄ… sposobu na automatyzacjÄ™ wielu zadaÅ„, ktÃ³re
    regularnie wykonujesz jako czÄ™Å›Ä‡ swojego procesu pracy programistycznej.
    NiezaleÅ¼nie od tego, czy chodzi o generowanie szablonÃ³w komponentÃ³w i
    funkcjonalnoÅ›ci, zapewnienie, Å¼e biblioteki sÄ… generowane i organizowane w
    okreÅ›lony sposÃ³b, czy teÅ¼ aktualizacjÄ™ plikÃ³w konfiguracyjnych, generatory
    pomagajÄ… w standaryzacji tych zadaÅ„ w spÃ³jny i przewidywalny sposÃ³b.
  </M>
  <M>IstniejÄ… trzy gÅ‚Ã³wne rodzaje generatorÃ³w:</M>
  <M>
    ğŸ› ï¸ generatory lokalne to generatory, ktÃ³re tworzÄ… szablony komponentÃ³w,
    usÅ‚ug, funkcjonalnoÅ›ci, itd.,
  </M>
  <M>Schemat wywoÅ‚ywania:</M>
  <Code mode="static" lang="javascript">
    {`nx generate
    [plugin]:[generator-name]
    [options]`}
  </Code>
  <L>
    <Li>
      <B>plugin</B>- nazwa pluginu,
    </Li>
    <Li>
      <B>generator-name</B>- nazwa generatora,
    </Li>
    <Li>
      <B>options</B>- dodatkowe opcje
    </Li>
  </L>
  <M>
    ğŸš€ generatory aktualizacji sÄ… wywoÅ‚ywane przez pluginy Nx podczas
    aktualizacji ich w celu utrzymania plikÃ³w konfiguracyjnych w synchronizacji
    z najnowszymi wersjami narzÄ™dzi. Dany generator jest wywoÅ‚ywany podczas
    wywoÅ‚ywania polecenia:
  </M>
  <Code mode="static" lang="tsx">
    {`nx migrate [plugin]`}
  </Code>
  <M>
    <B>Jak stworzyÄ‡ wÅ‚asny generator?</B>
  </M>
  <M>NaleÅ¼y wykonaÄ‡ polecenie:</M>
  <Code mode="static" lang="javascript">
    {`nx generate
    @nrwl/nx-plugin:generator
    [my-generator]
    --project=[my-plugin]`}
  </Code>
  <L>
    <Li>
      <B>my-plugin</B> - nazwa wczeÅ›niej utworzonego pluginu,
    </Li>
    <Li>
      <B>my-generator</B>- nazwa generatora
    </Li>
  </L>
  <M>Generator stworzy strukturÄ™ plikÃ³w projekcie takÄ… jak ta:</M>
  <Image
    src="https://github.com/WojtG/article-assets/blob/main/NRWL%20Extension/imgs/img3.png?raw=true"
    description="Struktura plikÃ³w"
  />
  <M>
    Plik generator.ts to caÅ‚a logika generatora. Plik ten zawiera funkcjÄ™, ktÃ³ra
    jest wywoÅ‚ywana w celu przeprowadzenia manipulacji na drzewie
    reprezentujÄ…cym system plikÃ³w. Plik schema.json zawiera opis generatora,
    dostÄ™pne opcje, informacje o walidacji oraz wartoÅ›ci domyÅ›lne (tak samo jak
    w przypadku egzekutora).
  </M>
  <M>Plik generator.ts:</M>
  <Code
    mode="dynamic"
    lang="typescript"
    src="https://raw.githubusercontent.com/WojtG/article-assets/main/NRWL%20Extension/snippet2.ts?token=GHSAT0AAAAAACIWZ2RVHQYRIDS6JSXJTIIKZKSCHUQ"
    linesCount={10}
  />
  <M>
    Parametr tree reprezentuje strukturÄ™ plikÃ³w. Pozwala usuwaÄ‡, dodawaÄ‡,
    edytowaÄ‡ pliki. Devkit dostarcza wielu narzÄ™dzi uÅ‚atwiajÄ…cych pracÄ™ z
    plikami. Np. w powyÅ¼szym przykÅ‚adzie funkcja installPackageTask instaluje
    pakiety nodowe. Dodatkowo moÅ¼emy teÅ¼ skorzystaÄ‡ w ramach wÅ‚asnego generatora
    z innych generatorÃ³w. Funkcja libraryGenerator tworzy bibliotekÄ™ na
    podstawie innego generatora.
  </M>
  <M>Plik schema.json:</M>
  <Code mode="static" lang="json">
    {`{
    "cli": "nx",
    "id": "test",
    "type": "object",
    "properties": {
    "name": {
    "type": "string",
    "description": "Nazwa nowej
    biblioteki",
    "$default": {
    "$source": "argv",
    "index": 0
    }
    }
    },
    "required": ["name"]
    }
    `}
  </Code>
  <M>
    Obiekt $default jest uÅ¼ywany do odczytywania argumentÃ³w z wiersza polecenia,
    ktÃ³re sÄ… przekazywane do generatora.
  </M>
  <M>Tak stworzony generator uruchamiamy z wiersza poleceÅ„ nastÄ™pujÄ…co:</M>
  <Code mode="static" lang="javascript">
    {`nx generate
    @myorg/[my-plugin]:[my-generator]
    [mylib]`}
  </Code>
  <L>
    <Li>
      <B>my-plugin</B>- nazwa wczeÅ›niej utworzonego pluginu,
    </Li>
    <Li>
      <B>my-generator</B> - nazwa generatora,
    </Li>
    <Li>
      <B>mylib</B> - nazwa wygenerowanej biblioteki
    </Li>
  </L>
</Section>
<Section>
  <XL>Publikacja CLI dla wielu projektÃ³w projektÃ³w</XL>
  <M>
    W ramach NRWL Extension moÅ¼emy teÅ¼ stworzyÄ‡ paczkÄ™ NPM, ktÃ³rÄ… moÅ¼e sÅ‚uÅ¼yÄ‡
    jako CLI z funkcjonalnoÅ›ciami niezaleÅ¼nymi od danego projektu. Takie CLI
    moÅ¼e nam daÄ‡ duÅ¼o standardÃ³w w ramach zespoÅ‚u, czy nawet caÅ‚ej organizacji
    takich jak:
  </M>
  <M>
    â›´ï¸ Przygotowanie stanowiska pracy, zainstalowanie odpowiednich wersji
    narzÄ™dzi, takich samych jak u innych deweloperÃ³w.
  </M>
  <M>ğŸ›¸ Tworzenie projektÃ³w wedÅ‚ug schematu stosowanego w projekcie.</M>
  <M>
    <B>Jak stworzyÄ‡ wÅ‚asne CLI w workspace NX?</B>
  </M>
  <M>NaleÅ¼y stworzyÄ‡ bibliotekÄ™ js poleceniem:</M>
  <Code mode="static" lang="javascript">
    {`nx generate
    @nrwl/workspace:library [my-cli]
    --buildable`}
  </Code>
  <L>
    <Li>
      <B>my-cli</B>- nazwa projektu do cli
    </Li>
  </L>
  <M>
    Dodatkowy pakiet NPM yargs moÅ¼e nam uÅ‚atwiÄ‡ przekazywanie argumentÃ³w do
    konsoli. Instalujemy te narzÄ™dzie poleceniem:
  </M>
  <Code mode="static" lang="javascript">
    {`npm install yargs`}
  </Code>
  <M>
    W folderze z bibliotekÄ… tworzymy folder bin, a w nim plik my-cli.js, ktÃ³ry
    ma nastÄ™pujÄ…cÄ… treÅ›Ä‡:
  </M>
  <Code mode="static" lang="javascript">
    {`#!/usr/bin/env node
    require('../src/lib/cli.js')`}
  </Code>
  <M>
    Pozwala to na odwoÅ‚anie do ÅºrÃ³dÅ‚a cli, ktÃ³re bÄ™dzie pod Å›cieÅ¼kÄ…
    src/lib/cli.js. TreÅ›Ä‡ takiego ÅºrÃ³dÅ‚a moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:
  </M>
  <Code
    mode="dynamic"
    lang="javascript"
    src="https://raw.githubusercontent.com/WojtG/article-assets/main/NRWL%20Extension/snippet3.js?token=GHSAT0AAAAAACIWZ2RV5MA73CNS26JB3PD2ZKSCXEQ"
    linesCount={16}
  />
  <M>
    Taka konfiguracja daje nam komendÄ™ init, z parametrem name (alias n) i
    wywoÅ‚uje funkcjÄ™ workspaceInit, ktÃ³ra moÅ¼e przechowywaÄ‡ logikÄ™ tworzenia
    projekt. Np. inicjalizacjÄ™ workpsace NX.{" "}
  </M>
  <M>
    Przed publikacjÄ… biblioteki w rejestrze NPM musimy jeszcze tylko odpowiedni
    skonfigurowaÄ‡ plik package.json:
  </M>
  <Code
    mode="dynamic"
    lang="json"
    src="https://raw.githubusercontent.com/WojtG/article-assets/main/NRWL%20Extension/snippet4.json?token=GHSAT0AAAAAACIWZ2RUO7JSIFICFJ6DFXLOZKSCYJA"
    linesCount={14}
  />
  <M>
    Taka konfiguracja pozwala po opublikowaniu i pobraniu globalnie pakietu NPM
    na uÅ¼ycie wÅ‚asnego CLI przez wywoÅ‚ania w wierszu poleceÅ„:
  </M>
  <Code mode="static" lang="javascript">
    {`my-cli init -â€”name=[new-project]`}
  </Code>
  <L>
    <Li>
      <B>new-project</B>- nazwa nowego projektu
    </Li>
  </L>
</Section>
<Summary label="Podsumowanie">
  <M>
    WÅ‚asne CLI daje nam bardzo duÅ¼o moÅ¼liwoÅ›ci standaryzacji i automatyzacji
    pracy przy projektach. NarzÄ™dzie do monorepo NRWL Extension daje duÅ¼o
    moÅ¼liwoÅ›ci na tworzenie i rozwijanie CLI od projektu do caÅ‚ej organizacji. W
    ramach tego artykuÅ‚u zostaÅ‚y pokazane podstawy tworzenia i uÅ¼ywania CLI.
  </M>
</Summary>
