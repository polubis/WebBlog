---
cdate: 2023-04-24
mdate: 2023-04-24
authorId: polubis
treviewerId: kwozniak
lreviewerId: kreszko
langs: ["en"]
lang: pl
tags: testy,optymalizacja
stack: javascript,typescript
description: Przeprowadzimy testy weryfikujce jaki wpyw na szybko programu mog mie r贸偶ne ptle w JavaScript.
readTime: 7
seniorityLevel: intermediate
title: Ptle w JavaScript oraz ich performance
---

<Prelude label="Wstp">
  <M>
    Widziaem kiedy <B>pull requesta</B>, w kt贸rym dw贸ch developer贸w k贸cio
    si o zastosowan ptl. Sytuacja bya o tyle zabawna, 偶e zrobia si z tego
    duga konwersacja, w kt贸rej ka偶dy spamowa linkami do wtk贸w na{" "}
    <B>Github</B> i do artyku贸w.
  </M>
  <M>
    To mnie zaciekawio... Nigdy nie miaem czasu sprawdzi, kt贸ra z dostpnych
    mo偶liwoci jest najlepsza. Artykuy poruszajce ten temat byy
    powierzchowne. Dlatego postanowiem wyedukowa si od podszewki i o tym w
    dzisiejszym wpisie.
  </M>
  <Hint hasBg>Dowiadczenie i wiedza dziaaj cuda .</Hint>
</Prelude>

<Section>
  <XL>1. Jak mierzy zo偶ono obliczeniow w JavaScript?</XL>
  <M>
    Nie da si stwierdzi ile dokadnie czasu zajmuje wywoanie konkretnej
    funkcji oraz co ciekawsze, za ka偶dym pomiarem s to r贸偶ne wartoci. Na
    pierwszy rzut oka jest to bardzo dziwne, ale pomyl - procesor robi o wiele
    wicej ni偶 jaki durny programik w JavaScript, a przegldarka o wiele wicej
    ni偶 uruchamianie twojego kodu.
  </M>
  <M>
    Skoro wiemy ju偶, 偶e pomiar czasu jest niedokadny to wiemy te偶, 偶e jako
    mo偶emy go mierzy. JavaScript ma wbudowane API, a nawet kilka. My skupimy
    si tylko na <B>performance.now()</B>, bo to nie zastosowane API w tym
    przypadku robi r贸偶nice, a spos贸b pomiaru i to co mierzymy.
  </M>
  <Code
    mode="dynamic"
    lang="ts"
    linesCount={10}
    description="Funkcja mierzca czas trwania dowolnej innej funkcji"
    src="https://raw.githubusercontent.com/polubis/loops-performance-in-javascript/main/src/performance/measure.ts"
  />
  <Code
    mode="dynamic"
    lang="ts"
    linesCount={12}
    description="Przykadowe wykorzystanie funkcji measure"
    src="https://raw.githubusercontent.com/polubis/loops-performance-in-javascript/main/src/snippets/memory-used.ts"
  />
  <M>
    Udowodniem Ci, 偶e czas si r贸偶ni. Teraz musimy ustali jak mo偶emy
    stwierdzi, kt贸ra ptla jest szybsza. Zastosujemy technik, kt贸ra nazywa si{" "}
    <B>pr贸bkowaniem</B>. Zamiast wywoywa testowany kod raz i por贸wnywa go z
    rezultatem innego programu uruchomimy go tysice/miliony razy i obliczymy
    sum czas贸w przy ka偶dym wywoaniu.
  </M>
  <Hint hasBg>
    Odpal na swoim komputerze podany kod i sprawd藕 jak uruchomienie program贸w
    wpywa na wynik dowolnej funkcji .
  </Hint>
</Section>

<Section>
  <XL>2. Pr贸bkujemy i zbieramy</XL>
  <M>
    Mamy funkcj <B>measure()</B>, wic teraz musimy j uruchomi <B>n</B> razy.
  </M>
  <Code
    mode="dynamic"
    lang="ts"
    linesCount={22}
    description="Funkcja do zbierania wynik贸w"
    src="https://raw.githubusercontent.com/polubis/loops-performance-in-javascript/main/src/performance/run-probes.ts"
  />
  <Code
    mode="dynamic"
    lang="ts"
    linesCount={12}
    description="Wykorzystanie funkcji runProbes()"
    src="https://raw.githubusercontent.com/polubis/loops-performance-in-javascript/main/src/snippets/run-probes-used.ts"
  />
</Section>

<Section>
  <XL>3. Wywietlanie i logowanie</XL>
  <M>
    Na tym etapie mamy czyste dane, ale kto by je tam chcia rcznie przeglda.
    Musimy je podliczy i zaokrgli do czterech miejsc po przecinku. Tylko do
    czterech, bo je偶eli co trwa <B>0.00001532</B> sekundy to um贸wmy si -
    u偶ytkownik tego raczej nie zauwa偶y.
  </M>
  <Code
    mode="dynamic"
    lang="ts"
    linesCount={31}
    description="Funkcja do podsumowania wyniku"
    src="https://raw.githubusercontent.com/polubis/loops-performance-in-javascript/main/src/performance/summarize.ts"
  />
  <Code
    mode="dynamic"
    lang="ts"
    linesCount={23}
    description="Mamy rezultat"
    src="https://raw.githubusercontent.com/polubis/loops-performance-in-javascript/main/src/snippets/summary-used.ts"
  />
  <M>
    Co my tu mamy? Wywoalimy funkcj sumujc trzy razy przekazujc do niej
    sze liczb od <B>1 do 6</B>. Cakowity czas trwania tych oblicze wyni贸s{" "}
    <B>0.0101</B> sekundy.
  </M>
  <Hint hasBg>
    JS jest dziwny. Uruchom kod trzy razy i zobacz, 偶e wartoci s r贸偶ne.
  </Hint>
</Section>

<Section>
  <XL>4. Ptle i rekurencje</XL>
  <M>
    Napiszemy kilka funkcji, kt贸re bda miay za zadanie obliczy sum dowolnych
    liczb (czyli ka偶da zrobi to samo, ale inaczej). P贸藕niej por贸wnamy wynik z
    gotowym narzdziem do sprawdzania optymalizacji i wycigniemy wnioski.
  </M>
  <Code
    mode="dynamic"
    lang="ts"
    linesCount={49}
    description="Masz jakiego faworyta?"
    src="https://raw.githubusercontent.com/polubis/loops-performance-in-javascript/main/src/sum.ts"
  />
  <M>
    Teraz ten sam zbi贸r danych przeka偶emy do ka偶dej z nich i wycigniemy
    wnioski.
  </M>
  <Code
    mode="dynamic"
    lang="tsx"
    linesCount={82}
    description="Pokazujemy rezultat i dajemy mo偶liwo zmiany parametr贸w"
    src="https://raw.githubusercontent.com/polubis/loops-performance-in-javascript/main/src/App.tsx"
  />
  <M>
    Zakadam, 偶e rzuci Ci si w oczy brak wywoania <B>recursiveSum</B>. Jest
    to celowe. Tutaj may spoiler - ta implementacja bdzie miaa najgorszy
    wynik. Na tyle zy, 偶e przepeni <B>stos wywoa</B> i wywali nasz program
    .
  </M>
</Section>

<Section>
  <XL>5. Sprawd藕my wyniki</XL>
  <M>
    W momencie gdy danych jest mao (100-1000) to nie wida wikszej r贸偶nicy.
    Wyglda nawet na to, 偶e wyniki s losowe (trwa to tak kr贸tko, 偶e nie ma
    r贸偶nicy, kt贸rej implementacji u偶yjemy). Wszystko zmienia si w momencie, gdy
    danych jest wicej. Nagle okazuje si, 偶e ptla <B>for</B> pojawia si na
    pierwszym miejscu zawsze, a r贸偶nica pomidzy pozostaymi jest znaczna.
  </M>
  <Image
    rolled
    src="/assets/loops-performance-in-javascript/demo.gif"
    description="Testy w naszej mini apce"
  />
  <M>
    Dlaczego tak si dzieje? Nowoczesne procesory s bardzo szybkie. Je偶eli nie
    s obci偶one to nie bdzie wida wikszej r贸偶nicy pomidzy dziaaniem
    programu, przede wszystkim je偶eli algorytm jest ten sam. W momencie
    zwikszania zbioru liczb procesor zaczyna si "mczy" (a raczej
    przegldarka), wic zaczynamy widzie r贸偶nice w pomiarach.
  </M>
  <M>
    Dodatkowo nale偶y pamita, 偶e JavaScript jest przeksztacany w zale偶noci od
    implementacji silnika do jzyka poredniego, a nastpnie do kodu
    maszynowego. Wic implementacja, kt贸ra kryje si wewntrz jest dla nas
    programist贸w nieznana. Mo偶e by tak, 偶e ptla <B>for</B> ma przewag nad{" "}
    <B>while</B>, bo kod "pod spodem" jest do tego zoptymalizowany.
  </M>
  <M>
    Jednak nie mo偶na powiedzie, 偶e ptla <B>for</B> zawsze bdzie najszybsza.
    Na pewno nie w oparciu o dane zebrane na maych zbiorach liczb. To ju偶
    zale偶y tylko i wycznie od problemu. Mo偶emy powiedzie, 偶e dla tego
    problemu ptla <B>for</B> jest najszybsza dla zbioru z jakiego przedziau,
    a nie 偶e jest "najszybsza".
  </M>
  <M>
    Jeszcze jedna sprawa. Dlaczego w takim razie metody wbudowane w prototyp{" "}
    <B>Array</B> s wolniejsze, je偶eli i tak u偶ywaja ptli <B>for</B> wewntrz?
    Jest to spowodowane dodatkowymi operacjami, na kt贸re jako developerzy si
    godzimy zyskujc na przejrzystoci kodu a tracc na jego szybkoci (w myl
    zasady co za co). Wykorzystane abstrakcje jak <B>forEach</B> oraz{" "}
    <B>reduce</B> wykonuj dodatkowe sprawadzenia przy ka偶dej iteracji, wic to
    zo偶yo si na ich gorszy wynik w por贸wnaniu do <B>while</B> czy <B>for</B>.
    Jako dow贸d podaje link do{" "}
    <A
      outside
      src="https://tc39.es/ecma262/multipage/indexed-collections.html?fbclid=IwAR1FkOVuwIUDfjfgr2TpsxSDnPY2MFW65-eOndDcifPjMnUt6_3h2yZOGBM#sec-array.prototype.foreach"
    >
      specyfikacji
    </A>
    .
  </M>
  <Hint hasBg>
    Dzikuje dla{" "}
    <A href="https://www.linkedin.com/in/pwolaq/" outside>
      Pawa Wolaka
    </A>{" "}
    za pomoc w tym miejscu.
  </Hint>
</Section>

<Section>
  <XL>6. Jaki rezultat dao gotowe narzdzie?</XL>
  <M>
    W internecie jest ich naprawd sporo, a ja postanowiem wybra
    najadniejsze, czyli{" "}
    <A href="https://perf.link/" outside>
      perf.link
    </A>{" "}
    (taka przypado u frtasi). Wrzuciem wczeniejsze przykady i wyszed mi
    dokadnie taki sam werdykt. Ptla <B>for</B> przodowaa przy wikszych
    zbiorach liczb, a przy mniejszych nie mo偶na byo oceni, kt贸ra jest
    najlepsza. Sprawdziem te偶 funkcj rekurencyjn. Tak samo jak wczeniej od
    samego pocztku odstawaa nawet na iloci 100 element贸w. Tak prezentuje si
    wynik dla stu tysicy numer贸w.
  </M>
  <Hint hasBg>Jak widzisz rekurencja nie dziaa.</Hint>
  <Image
    rolled
    src="/assets/loops-performance-in-javascript/perf.jpg"
    description="Wniosek jest ten sam"
  />
  <M>
    Do dyspozycji s jeszcze fajne biblioteki. Ja wykorzystwaem czsto{" "}
    <A href="https://benchmarkjs.com/" outside>
      Benchmark.js
    </A>
    , kt贸ra w mojej opini jest wietna oraz przypomina pisanie zwykych test贸w jednostkowych.
    Tym razem bd to jednak testy szybkoci dziaania programu a nie tego czy prawidowo
    dziaa.
  </M>
  <Code mode="static" lang="javascript" description="Piknie to wyglda">
    {`
    const suite = new Benchmark.Suite;
    
suite.add('RegExp#test', () => {
  /o/.test('Hello World!');
})
.add('String#indexOf', () => {
  'Hello World!'.indexOf('o') > -1;
})
.add('String#match', () => {
  !!'Hello World!'.match(/o/);
})
.on('cycle', (event) => {
  console.log(String(event.target));
})
.on('complete', () => {
  console.log('Fastest is ' + this.filter('fastest').map('name'));
})
.run({ 'async': true });`}
  </Code>
</Section>

<Example>
  <M>
    <A
      href="https://codesandbox.io/p/github/polubis/loops-performance-in-javascript/main?file=%2Fsrc%2FApp.tsx&selection=%5B%7B%22endColumn%22%3A13%2C%22endLineNumber%22%3A37%2C%22startColumn%22%3A13%2C%22startLineNumber%22%3A37%7D%5D&workspace=%257B%2522activeFilepath%2522%253A%2522%252Fsrc%252Fsum.ts%2522%252C%2522openFiles%2522%253A%255B%2522%252Fsrc%252FApp.tsx%2522%252C%2522%252Fsrc%252Fperformance%252Fsummarize.ts%2522%252C%2522%252Fsrc%252Fperformance%252Frun-probes.ts%2522%252C%2522%252Fsrc%252Fsnippets%252Frun-probes-used.ts%2522%252C%2522%252Fsrc%252Fsum.ts%2522%252C%2522%252Fsrc%252Fsnippets%252Fsummary-used.ts%2522%255D%252C%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522gitSidebarPanel%2522%253A%2522COMMIT%2522%252C%2522spaces%2522%253A%257B%2522clgne8f5s043d356qd2gxmgto%2522%253A%257B%2522key%2522%253A%2522clgne8f5s043d356qd2gxmgto%2522%252C%2522devtools%2522%253A%255B%257B%2522type%2522%253A%2522PREVIEW%2522%252C%2522taskId%2522%253A%2522start%2522%252C%2522port%2522%253A3000%252C%2522key%2522%253A%2522clgne8jkc0450356q218ukqxi%2522%252C%2522isMinimized%2522%253Afalse%257D%252C%257B%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%252C%2522key%2522%253A%2522clgnea0u405c3356q85mp2ehc%2522%252C%2522isMinimized%2522%253Atrue%257D%255D%252C%2522name%2522%253A%2522start%2520Preview%2522%257D%257D%252C%2522currentSpace%2522%253A%2522clgne8f5s043d356qd2gxmgto%2522%252C%2522spacesOrder%2522%253A%255B%2522clgne8f5s043d356qd2gxmgto%2522%255D%252C%2522hideCodeEditor%2522%253Afalse%257D
"
      outside
    >
      Code sandbox
    </A>{" "}
    do zabawy oraz{" "}
    <A
      href="https://github.com/polubis/loops-performance-in-javascript"
      outside
    >
      repozytorium
    </A>{" "}
    z gotowym kodem.
  </M>
</Example>

<Summary label="Podsumowanie">
  <M>
    Po tym wpisie ju偶 wiesz, 偶e mierzenie zo偶onoci obliczeniowej mo偶e by
    "tricky". Okazao si, 偶e ci偶ko jest stwierdzi, kt贸ra ptla jest
    najszybsza.
  </M>
  <M>
    Skadnia jzyka jest istotna, ale nie a偶 tak jak algorytm i umiejtnoci
    programisty, po stronie kt贸rych stoi odpowied藕 na pytanie - kt贸re
    rozwizanie jest szybsze?
  </M>
  <M>
    Pamitaj, 偶e zo偶ono pamiciowa jest tak偶e istotna a czasami nawet
    wa偶niejsza. Myl, 偶e jednak o tym innym razem.
  </M>
  <M>
    Je偶eli Ci si podobao to pamitaj odwiedzi nas na{" "}
    <A href="https://www.linkedin.com/in/adrian-po%C5%82ubi%C5%84ski-281ab2172/" outside>
      Linkedin
    </A>{" "}
    gdzie regularnie wrzucamy content z programowania.
  </M>
  <Hint hasBg>
    "Czowiek uczy si przez cae 偶ycie a robi to zazwyczaj odkrywajc koo na
    nowo. Od dziecistwa - do koca swoich dni." - cytat z ksi偶ki, mo偶e wiesz
    jakiej?
  </Hint>
</Summary>
