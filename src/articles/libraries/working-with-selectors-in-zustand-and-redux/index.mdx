---
cdate: 2023-09-10
mdate: 2023-09-10
authorId: polubis
treviewerId: kwozniak
lreviewerId: kreszko
lang: en
tags: libraries,comparision,fun
stack: typescript,react,redux,zustand
readTime: 6
seniorityLevel: intermediate
title: Working with selectors in Zustand and Redux
description: We'll dive into the selectors concept in the Zustand/Redux libraries and explore the different use cases for dynamic and static selectors.
---

<Prelude label="Why do we need selectors?">
  <M>Selectors have mainly the following purposes: </M>
  <L>
    <Li>
      reduce the amount of boilerplate connected with reading data from the
      store,
    </Li>
    <Li>
      improve the maintenance aspect - if your data is read in different places,
      with selectors you'll reduce the time required to refactor such code
      later,
    </Li>
    <Li>
      selectors may use flyweight pattern (memoization), so we can reduce
      rerenders for our components.
    </Li>
  </L>
</Prelude>

<Section>
  <XL>
    How selectors may reduce the amount of boilerplate connected with state
    reading?
  </XL>
  <Code
    description="Before selector usage"
    mode="static"
    lang="tsx"
  >{`// ❌ The same code in 3 components.
import { useSelector } from 'redux';
 
const ComponentA = () => {
  const users = useSelector((state) => state.usersReducer.users);
};
 
const ComponentB = () => {
  const users = useSelector((state) => state.usersReducer.users);
};
 
const ComponentC = () => {
  const users = useSelector((state) => state.usersReducer.users);
};
`}</Code>
  <Code
    mode="static"
    description="After selector usage"
    lang="tsx"
  >{`// ✅ With selector.
 
// selector.ts file.
import type { AppState } from './store';
 
export const getUser = (state: AppState): AppState['usersReducer']['user'] =>
  state.usersReducer.user;
 
// In components code: ComponentA, ComponentB, ComponentC files.
 
import { useSelector } from 'redux';
import { getUser } from './selectors';
// No more boilerplate and no code duplication.
const ComponentA = () => { 
  const users = useSelector(getUser);
};
 
const ComponentB = () => {
  const users = useSelector(getUser);
};
 
const ComponentC = () => {
  const users = useSelector(getUser);
};
`}</Code>
  <M>
    As you saw we reduced code duplication and boilerplate required to read
    state data property located in <B>Redux</B> slice.
  </M>
  <M>
    To achieve the same result in <B>Zustand</B>, we just need to use following
    code:{" "}
  </M>
  <Code mode="static" lang="tsx">{`// selectors.ts file.
const useUserSelector = () => {
  return useUserStore((state) => state.user);
};
 
// Inside ComponentA file.
import { useUserSelector } from './selectors';
 
const ComponentA = () => {
  const user = useUserSelector();
};
`}</Code>
  <M>
    In <B>Zustand</B> we have a little bit less code to write - it's because
    this library creates a hook for us. Of course for <B>Redux</B> we can create
    a hook by ourselves. We'll cover following topics later.
  </M>
</Section>

<Section>
  <XL>Improving the maintenance aspect with selectors</XL>
  <M>
    Imagine you want to change property inside <B>userSlice</B> when you're
    working with <B>Redux</B> or in <B>Zustand</B> store. Of course, if it's
    just 3 places it's not a big deal, but if it will be in 20 - we need to do
    much more.
  </M>
  <Code mode="static" description="In Redux" lang="tsx">{`// selector.ts file.
import type { AppState } from './store';
 
// User is user1 right now.
export const getUser = (state: AppState): AppState['usersReducer']['user1'] =>
  state.usersReducer.user1;
 
// In components code: ComponentA, ComponentB, ComponentC files.
 
import { useSelector } from 'redux';
import { getUser } from './selectors';
// Any changes required.
const ComponentA = () => {
  const users = useSelector(getUser);
};
 
const ComponentB = () => {
  const users = useSelector(getUser);
};
 
const ComponentC = () => {
  const users = useSelector(getUser);
};
`}</Code>
  <Code
    mode="static"
    description="In Zustand"
    lang="tsx"
  >{`// selectors.ts file.
const useUserSelector = () => {
  // User is user1 right now.
  return useUserStore((state) => state.user1);
};
  
// Inside ComponentA file.
import { useUserSelector } from './selectors';
// Any work required.
const ComponentA = () => {
  const user = useUserSelector();
};
`}</Code>
</Section>

<Section>
  <XL>Selectors and memoization - the "flyweight" pattern</XL>
</Section>

<Section>
  <XL>Creating Zustand selector</XL>
  <M>

  </M>
</Section>

<Section>
  <XL>Static selectors</XL>
  <M>

  </M>
</Section>

<Section>
  <XL>Dynamic selectors</XL>
  <M>

  </M>
</Section>

<Section>
  <XL>The rendering aspect of selectors</XL>
  <M>

  </M>
</Section>

<Section>
  <XL>Little tweaks for better readability and naming - conventions</XL>
  <M>

  </M>
</Section>

<Summary label="Conclusions and thoughts">
  <M>
    We explored the <B>selectors</B> concept in <B>Zustand</B> and now you know
    how to create <B>dynamic</B> and <B>static</B> selectors.
  </M>
  <M>
    Now you know that <B>selectors</B> are an excellent mechanism to reduce
    rendering impact in <B>React</B> applications. They provide better
    readability, reduce the extraction of data logic from complex models, and
    allow us to refactor our state management more easily.
  </M>
  <M>
    As you saw it's good to <B>encapsulate</B> your selectors in <B>object</B>{" "}
    for better <B>readability</B> and to reduce weird names. Of course, you may
    have different opinion, but I like to structure my code in a consistent way
    (in presented approach we did that).{" "}
  </M>
</Summary>
