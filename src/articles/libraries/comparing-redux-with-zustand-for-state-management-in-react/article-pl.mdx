---
cdate: 2023-07-16
mdate: 2023-07-16
authorId: polubis
treviewerId: goteii
lreviewerId: kzalewska
tags: state,libraries,comparision
lang: pl
langs: ["en"]
stack: react,redux,typescript,zustand,jest
description: Przeanalizujemy główne cechy Redux Toolkit i Zustand oraz przedstawimy ich wady i zalety. Przybliżymy różnice w podejściu i składni tych narzędzi.
readTime: 10
seniorityLevel: expert
title: Zarządzanie stanem w React. Redux toolkit czy Zustand?
---

<Prelude label="Wybór biblioteki do state managementu w React">
  <M>
    Jest to bardzo problematyczny i skomplikowany temat. Długo lawirowałem
    pomiędzy <B>Redux toolkit</B>, a <B>ContextAPI</B>. Po jakimś czasie zawsze
    dochodziłem do tego samego pytania - czy jest jakaś alternatywa? Jest ich
    całkiem sporo i jakbym miał wymieniać, to nie starczyło by mi dnia.
  </M>
  <M>
    Szukałem czegoś bardzo prostego, produkującego małą ilość <B>boilerplate</B>{" "}
    i wspierającego modułowe podejście - bo to zapewnia mały rozmiar aplikacji
    oraz jest wygodne w utrzymaniu. I znalazłem!{" "}
  </M>
  <M>
    Dziś zajmiemy się porównaniem możliwości <B>Zustand</B> oraz{" "}
    <B>Redux toolkit</B>.
  </M>
</Prelude>

<Section>
  <XL>Założenia Redux</XL>
  <L>
    <Li>Jeden store</Li>
    <Li>Zmiany w store są wykonywane za pomocą funkcji dispatch</Li>
    <Li>
      Do funkcji dispatch należy przekazać akcję (obiekt mający unikalny klucz
      oraz dodatkowe dane)
    </Li>
    <Li>Implementuje wzorzec CQRS</Li>
    <Li>
      Bazuje na architekturze FLUX (modyfikuje ją - zamiast wielu store mamy
      jeden)
    </Li>
    <Li>
      Implementuje reducery (sprawdzają typ podanej akcji i zmieniają stan w
      oparciu o przekazane dane)
    </Li>
    <Li>Posiada middleware</Li>
    <Li>Wszystkie reducery są finalnie scalane do jednego</Li>
    <Li>Funkcja subscribe działa dla całego store</Li>
    <Li>Posiada selektory</Li>
    <Li>Struktura monolitu - jak wielka baza danych</Li>
    <Li>Brak modułowości</Li>
    <Li>
      Wymaga wrappera (StoreProvider) - coś co zintegruje Reduxa z Reactem
    </Li>
  </L>
  <M>
    <B>Elementy składowe: </B>
  </M>
  <L>
    <Li>Store (jeden)</Li>
    <Li>Reducery</Li>
    <Li>Middleware</Li>
    <Li>Akcje</Li>
    <Li>Action creatory - funkcje tworzące obiekty akcji</Li>
    <Li>Selektory</Li>
    <Li>Hooki do odczytu oraz modyfikacji stanu</Li>
    <Li>Dispatcher</Li>
    <Li>Slice (w przypadku Redux toolkit)</Li>
    <Li>Acts (w przypadku Redux toolkit)</Li>
  </L>
</Section>

<Section>
  <XL>Założenia Zustand</XL>
  <L>
    <Li>Więcej niż jeden store</Li>
    <Li>Zmiany w store dokonujemy za pomocą akcji - zwykła funkcja</Li>
    <Li>Implementuje architekturę FLUX</Li>
    <Li>Brak reducerów</Li>
    <Li>Brak funkcji dispatch</Li>
    <Li>Brak CQRS</Li>
    <Li>Posiada middleware dla każdego store oddzielnie</Li>
    <Li>Modułowość</Li>
    <Li>Posiada funkcję subscribe per store</Li>
    <Li>Posiada selektory</Li>
    <Li>Nie wymaga wrappera</Li>
  </L>
  <M>
    <B>Elementy składowe: </B>
  </M>
  <L>
    <Li>Więcej niż jeden store</Li>
    <Li>Akcje</Li>
    <Li>Selektory</Li>
    <Li>Middleware - per store</Li>
    <Li>Hook do wywoływania akcji i odczytu stanu (jeden)</Li>
  </L>
</Section>

<Section>
  <XL>Setup dla Redux toolkit</XL>
  <M>
    Na początek spięcie <B>Redux</B> z <B>React</B> - zwróć uwagę na{" "}
    <B>Provider</B> i przekazany do niego <B>store</B>.
  </M>
  <Code lang="tsx" mode="static">{`
import React from "react"
import ReactDOM from "react-dom"
import App from "./App"
import { store } from "./app/store"
import { Provider } from "react-redux"
 
ReactDOM.render(
  // Jeden "store", wykuty do rządzenia wszystkimi komponentami.
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)`}</Code>
  <M>
    Teraz czas na <B>slice</B>, który wygeneruje nam <B>reducery</B> oraz{" "}
    <B>akcje</B>.
  </M>
  <Code lang="ts" mode="static">{`
import type { Post } from "models/posts"
import { createSlice, type PayloadAction } from "@reduxjs/toolkit"
 
interface PostsState {
  loading: boolean
  posts: Post[]
  error: string
}
    
const postsSlice = createSlice({
  name: 'posts',
  initialState: <PostsState>{
    loading: false,
    posts: [],
    error: ""
  },
  reducers: {
    addPost(state, action: PayloadAction<Post>) {
      state.posts.push(action.payload)
    }
  },
})
 
export default postsSlice 
`}</Code>
  <M>
    Finalnie i tak wszystkie <B>reducery</B> muszą być scalone do jednego - plik{" "}
    <B>reducers.ts</B>.
  </M>
  <Code lang="ts" mode="static">{`
  import { combineReducers } from "redux"
 
import postsSlice from "./posts/postsSlice"
// W przyszłości lista importów znacznie urośnie.
 
export default combineReducers({
  posts: postsSlice.reducer,
  // To też urośnie...
})
`}</Code>
  <M>
    No i jeszcze potrzebujemy pliku <B>store.ts</B>, w którym wszystko
    połączymy.
  </M>
  <Code
    lang="ts"
    mode="static"
  >{`import { configureStore } from "@reduxjs/toolkit"
import { useDispatch, useSelector, type TypedUseSelectorHook } from "react-redux"
import reducer from './reducers'
import thunk from 'redux-thunk'
 
export const store = configureStore({
  reducer,
  middleware: [thunk]
})
 
// Typy dla naszego store.
export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch
 
// Hooki do odczytu danych oraz wywoływania zmian.
export const useAppDispatch: () => AppDispatch = useDispatch
export const useAppSelector: TypedUseSelectorHook<AppState> = useSelector
`}</Code>
  <M>Teraz kod w komponencie.</M>
  <Code
    lang="tsx"
    mode="static"
  >{`import { useAppSelector, useAppDispatch } from "store"
import { addPost } from "actions/posts"
 
const AnyComponent = () => {
  const { posts, loading, error } = useAppSelector(({ posts }) => posts)
  const dispatch = useAppDispatch()
}
`}</Code>
  <M>
    Nie wiem jak <B>Ty</B>, ale ja widzę sporo kodu, który będzie jeszcze
    bardziej skomplikowany przy każdej nowej funkcjonalności.
  </M>
</Section>

<Section>
  <XL>Setup dla Zustand</XL>
  <M>
    Potrzebujemy <B>store</B>. To tyle! Będzie on miał zarówno <B>stan</B>, jak
    i zestaw <B>akcji</B>. Zwróć uwagę, że <B>usePostsStore</B> to hook!
  </M>
  <Code lang="ts" mode="static">{`import { create } from "zustand"
import type { Post } from "models/posts"
 
interface PostsStore {
  loading: boolean
  posts: Post[]
  error: string
  addPost: (post: Post) => void
}
 
const usePostsStore = create<PostsStore>((set) => ({
  loading: false,
  posts: [],
  error: '',
  addPost: (post) => {
    set((state) => ({ posts: [state.posts, post] }))
  },
}))
 
export { usePostsStore }
`}</Code>
  <M>
    Teraz wystarczy zaimportować <B>hook</B> stworzony przez <B>Zustand</B> do
    dowolnego komponentu i skorzystać ze stanu lub akcji.{" "}
  </M>
  <Code lang="tsx" mode="static">{`import { usePostsStore } from 'store/posts'
 
const AnyComponent = () => {
  const { loading, posts, error, addPost } = usePostsStore()
}
`}</Code>
  <M>
    Zwróć uwagę, jak mało było potrzebne, aby uzyskać dokładnie ten sam efekt co
    w <B>Redux</B>. To był tylko jeden plik!
  </M>
</Section>

<Section>
  <XL>Różnica w rozmiarze bibliotek</XL>
  <M>
    Na stronie{" "}
    <A outside href="https://bundlephobia.com/">
      Bundlephobia
    </A>{" "}
    wynik dla <B>Redux</B>, <B>React redux</B>, <B>Redux toolkit</B> oraz{" "}
    <B>Redux thunk</B> to: <B>1.8kB</B> + <B>4.9kB</B> + <B>3.6kB</B> +{" "}
    <B>236B</B> = <B>~10,537kB</B>.
  </M>
  <M>
    Dla <B>Zustand</B> jest to <B>1.1kB</B>. Dla internetu <B>slow 3G</B> będzie
    to:{" "}
  </M>
  <M>
    <B>Redux</B> = <B>~223ms</B>
  </M>
  <M>
    <B>Zustand</B> = <B>23ms</B>
  </M>
  <Hint hasBg>
    <B>Zustand</B> jest biblioteką, która nie ma żadnych dodatkowych zależności
    i nie będzie ich wymagała do uzyskania tych samych funkcjonalności, które
    oferuje ekosystem <B>Redux</B> (cztery wymienione biblioteki - patrz wyżej).
  </Hint>
</Section>

<Section>
  <XL>Boilerplate, a rozmiar aplikacji</XL>
  <M>
    Rozmiary bibliotek to jedno, ale istotny jest również wpływ na rozmiar
    aplikacji kodu, który musimy w nich napisać. Dla implementacji
    funkcjonalności z postami (patrz wyżej), rozmiary aplikacji (dla
    konfiguracji produkcyjnej) wynoszą:{" "}
  </M>
  <M>
    <B>Redux</B> = <B>126kB</B> (czysty projekt + feature postów).
  </M>
  <M>
    <B>Zustand</B> = <B>117KB</B> (czysty projekt + feature postów).
  </M>
  <M>Teraz 30 funkcjonalności o identycznej implementacji.</M>
  <M>
    <B>Redux</B> = <B>30</B> (liczba funkcjonalności) * <B>0.97kB </B> (rozmiar
    boilerplate per funkcjonalność) = <B>29,1kB</B>.
  </M>
  <M>
    <B>Zustand</B> = <B>30</B> (liczba funkcjonalności) * <B>0.44kB</B> (rozmiar
    boilerplate per funkcjonalność) = <B>13.2kB</B>.
  </M>
  <M>Zatem finalnie: </M>
  <M>
    <B>Redux</B> = <B>126kB</B> (rozmiar początkowy) + <B>29,1kB</B> (rozmiar 30
    funkcjonalności) = <B>155,1kB</B>.
  </M>
  <M>
    <B>Zustand</B> = <B>117KB </B> (rozmiar początkowy) + <B>13.2kB</B> (rozmiar
    30 funkcjonalności) = <B>130,2kB</B>.
  </M>
  <M>
    Czasowo dla <B>slow 3G</B>:{" "}
  </M>
  <M>
    <B>Redux</B> = <B>~3 456ms</B>
  </M>
  <M>
    <B>Zustand</B> = <B>~2 795ms</B>
  </M>
</Section>

<Section>
  <XL>Operacje asynchroniczne w Redux toolkit</XL>
  <M>
    Jeżeli korzystamy z <B>redux-thunk</B>, to operacje asynchroniczne
    obsługujemy w plikach <B>act</B>.{" "}
  </M>
  <Code lang="ts" mode="static">{`
// To jest w oddzielnym pliku - "actSignIn.ts".
import { createAsyncThunk } from "@reduxjs/toolkit"
import { type SignInPayload, signIn } from "api/auth"
 
export const actSignIn = createAsyncThunk(
  "auth/signIn",
  async (
    { payload }: { payload: SignInPayload },
    { rejectWithValue }
  ) => {
    try {
      // Funkcja "signIn" wykonuje zapytanie do API.
      const user = await signIn(payload)
      // Zwracamy zalogowanego użytkownika.
      return user
    } catch (error: unknown) {
      return rejectWithValue(error)
    }
  }
)
`}</Code>
  <M>
    Teraz w naszym <B>slice</B> możemy obsłużyc zmiany stanu.{" "}
    <B>Redux toolkit</B> automatycznie wygeneruje odpowiednie akcje -{" "}
    <B>pending</B>, <B>fulfilled</B> oraz <B>rejected</B>, w których musimy
    zdefiniować jak zmienić stan.{" "}
  </M>
  <Code lang="ts" mode="static">{`import { createSlice } from "@reduxjs/toolkit"
import { type SignedInUser } from "api/auth"
import { actSignIn } from "acts/actSignIn"
 
interface SignInState{
   loading: boolean
   error: string
   user: null | SignedInUser
}
 
const authSlice = createSlice({
  name: "auth",
  {
    loading: false,
    error: '',
    user: null,
  } as SignInState,
  extraReducers: (builder) => {
     // Tu obsługujemy zmiany stanu w momencie wywołania "actSignIn".
    builder
      .addCase(actSignIn.pending, (state) => {
        // Ten kod wywoła się po dispatch(actSignIn()).
        state.loading = true
        state.error = ''
        state.user = null
      })
      .addCase(actSignIn.fulfilled, (state, { payload }) => {
        // Ten kod wywoła się gdy actSignIn() coś zwróci.
        state.loading = false
        state.user = payload
      })
      .addCase(actSignIn.rejected, (state, { payload }) => {
        // Ten kod wywoła się gdy actSignIn() zwróci błąd - patrz "catch".
        state.loading = false
        state.error = payload
      })
  },
})
`}</Code>
  <M>
    Warto zwrócić uwagę, że zmiana stanu jest odseparowana od logiki zapytania
    do API. W <B>act</B> definiujemy co wywołać oraz co zwrócić, a w{" "}
    <B>slice</B> obsługujemy jak zmienić stan w oparciu o rezultat.
  </M>
</Section>

<Section>
  <XL>Operacje asynchroniczne w Zustand</XL>
  <M>
    W <B>Zustand</B> operacje asynchroniczne obsługujemy zwykłą funkcją z
    adnotacją <B>async</B>.
  </M>
  <Code
    lang="ts"
    mode="static"
  >{`import { type SignedInUser, type SignInPayload, signIn } from "api/auth"
 
interface SignInStore {
  loading: boolean
  error: string
  user: null | SignedInUser
  signIn: (payload: SignInPayload) => Promise<void>
}
 
const useSignInStore = create<SignInStore>((set) => ({
  loading: false,
  error: '',
  user: null,
  signIn: async (payload) => {
    set({ loading: true, error: '', user: null })
 
    try {
      const user = await signIn(payload)
 
      set({ loading: false, user })
    } catch (error: unknown) {
      set({ loading: false, error })
    }
  },
}))
`}</Code>
  <M>
    <B>Zustand</B> stosuje podejście, w którym modyfikacja wartości oraz ich
    odczyt jest w jednym miejscu - co sprawia, że kodu będzie mniej.
  </M>
</Section>

<Section>
  <XL>Bezpieczeństwo typów w Redux toolkit</XL>
  <M>
    W <B>Redux toolkit</B> typy są wnioskowane dla <B>act</B> na podstawie
    zwracanych wartości i jawnego typowania przekazywanych parametrów.{" "}
  </M>
  <Code lang="ts" mode="static">{`
// @@@ Wewnątrz "actSignIn.ts". @@@
export const actSignIn = createAsyncThunk(
  "auth/signIn",
  async (
    // Tu jawne typowanie "payload".
    { payload }: { payload: SignInPayload }, 
    { rejectWithValue }
  ) => {
    try {
      const user = await signIn(payload)
      // Typ dla obiektu "user" pozostanie "zapamiętany" dla
      // "actSignIn.fulfilled".
      return user
    } catch(error: unknown) {
      // Typ dla "error" pozostanie "zapamiętany" dla
      // "actSignIn.rejected".
      return rejectWithValue(error as string)
    }
  }
)
 
// @@@ Wewnątrz "authSlice.ts". @@@
 
.addCase(actSignIn.fulfilled, (state, { payload }) => {
  // Tutaj typ "payload" to "SignedInUser".
  // "Payload" to zwracana wartość przez "act".
  state.loading = false
  state.user = payload
})
.addCase(actSignIn.rejected, (state, { payload }) => {
  // Tutaj typ "payload" to "string".
  // W tym przypadku "payload" to zwracana wartość 
  // przez "rejectWithValue()".
  state.loading = false
  state.error = payload
});
`}</Code>
  <M>A jak wygląda typowanie zwykłych akcji? </M>
  <Code lang="ts" mode="static">{`
import type { PayloadAction } from "@reduxjs/toolkit"
 
reducers: {
  setUser(state, { payload }: PayloadAction<SignedInUser>) => {
    state.user = payload
  }
}
`}</Code>
  <M>
    No i na koniec typowanie stanu w <B>slice</B>.{" "}
  </M>
  <Code lang="ts" mode="static">{`
interface SignInState {
   loading: boolean
   error: string
   user: null | SignedInUser
} 
 
const authSlice = createSlice({
  name: "auth",
  {
    loading: false,
    error: '',
    user: null,
  } as SignInState
})`}</Code>
  <M>
    W <B>Redux toolkit</B> typy są częściowo dedukowane, więc zmieniając
    implementacje, zmieniamy też definicje typu dla akcji wywoływanych przez{" "}
    <B>act</B>. Jednocześnie jednak musimy stworzyć interfejs dla definicji{" "}
    <B>stanu</B> oraz wykorzystać <B>PayloadAction</B> do zdefiniowania{" "}
    <B>payload</B> dla konkretnej akcji, co wprowadza lekkie zamieszanie.
  </M>
</Section>

<Section>
  <XL>Bezpieczeństwo typów w Zustand</XL>
  <M>
    W <B>Zustand</B> wszystko definiujemy jawnie.
  </M>
  <Code lang="ts" mode="static">{`
interface SignInStore {
  loading: boolean
  error: string
  user: null | SignedInUser
  signIn: (payload: SignInPayload) => Promise<void>
}
 
const useSignInStore = create<SignInStore>((set) => ({
  loading: false,
  error: '',
  user: null,
  signIn: async (payload) => {
    // Typ dla "payload" to "SignInPayload".
  },
}))
`}</Code>
  <M>
    W <B>Zustand</B>, dzięki jawnej definicji interfejsu, mamy gwarancję, że
    definicja typów ma jedno źródło prawdy. Jeżeli zmienimy interfejs, to wiemy,
    że należy dostosować implementację.{" "}
  </M>
</Section>

<Section>
  <XL>Analiza nakładu pracy w Redux toolkit</XL>
  <M>Dla każdej nowej funkcjonalności musimy: </M>
  <L>
    <Li>Zaimplementować slice</Li>
    <Li>Stworzyć typy</Li>
    <Li>Zaimplementować acty</Li>
    <Li>Zaimplementować akcje</Li>
    <Li>Stworzyć plik z re-exportem akcji ze slice</Li>
    <Li>Stworzyć plik z re-exportem reducerów ze slice</Li>
    <Li>Zmodyfikować plik store</Li>
    <Li>Popracować nad integracją z komponentami</Li>
    <Li>Stworzyć testy dla każdej warstwy lub test integracyjny</Li>
    <Li>Wielokrotnie przełączać się pomiędzy wieloma plikami</Li>
  </L>
  <M>
    W przypadku jakiejś zmiany w logice biznesowej lub nazwie czegoś do czego
    odnoszą się elementy składowe, musimy przejrzeć wiele plików i upewnić się
    co do wprowadzonych zmian.{" "}
  </M>
</Section>

<Section>
  <XL>Analiza nakładu pracy w Zustand</XL>
  <M>Dla każdej nowej funkcjonalności musimy: </M>
  <L>
    <Li>Stworzyć typy</Li>
    <Li>Zaimplementować store (stan + akcje)</Li>
    <Li>Zintegrować się z komponentami</Li>
    <Li>Napisać testy jednostkowe lub test integracyjny</Li>
    <Li>Przełączamy się pomiędzy dwoma lub trzema plikami maksymalnie</Li>
  </L>
  <M>
    W <B>Zustand</B> operujemy głównie na pliku <B>store</B> i tam znajduje się
    wszystko czego potrzebujemy.
  </M>
</Section>

<Section>
  <XL>Implementacja redux-devtools-extension w Redux toolkit</XL>
  <Code lang="ts" mode="static">{`
  import { createStore, applyMiddleware } from "redux"
import { composeWithDevTools } from "redux-devtools-extension"
 
const store = createStore(
  rootReducer,
  composeWithDevTools(applyMiddleware(/* Dowolne inne middleware */))
)`}</Code>
</Section>

<Section>
  <XL>Implementacja redux-devtools-extension w Zustand</XL>
  <M>
    <B>Reduxowe devtoolsy</B> w <B>Zustand</B>? Przecież to nie <B>Redux</B>...
    Nie zmienia to faktu, że mamy taką możliwość. Tytuły dla akcji będą
    wygenerowane w oparciu o ich nazwy. Warto też zaznaczyć, że dla każdego{" "}
    <B>store</B> musimy je podpiąć oddzielnie - <B>Zustand</B> jest
    modułowy.{" "}
  </M>
  <Code lang="ts" mode="static">{`
import { create } from "zustand"
import { devtools } from "zustand/middleware"
   
const usePlainStore = create(devtools(store))`}</Code>
</Section>

<Section>
  <XL>Implementacja własnego middleware w Redux toolkit</XL>
  <M>Ten kod przechwyci wyjątek w kodzie i wyśle logi do bazy danych. </M>
  <Code mode="static" lang="tsx">{`
 // Wewnątrz reportException.ts
import type { Middleware } from "redux"
import { trackError } from "api/track"
import type { AppState } from "store"
 
const reportException: Middleware<{}, AppState> =
  (store) => (next) => (action) => {
    try {
      return next(action)
    } catch (err: unknown) {
      console.error('O cholerka coś się stało :(', err)
 
      trackError(err, window.location.href)
 
      throw err
    }
  }
 
// Wewnątrz store.ts
import { reportException } from "middleware/reportException.ts"
 
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(reportException),
})
`}</Code>
</Section>

<Section>
  <XL>Implementacja własnego middleware w Zustand</XL>
  <Code mode="static" lang="ts">{`
import { create, type StateCreator } from "zustand"
import { trackError } from "api/track"
import { SomeStoreType } from "./models"
 
const reportException =
  <T>(stateCreator: StateCreator<T>): StateCreator<T> =>
  (set, get, api) =>
    stateCreator(
      (args) => {
        try {
          set(args)
        } catch (err: unknown) {
          console.error('O cholerka coś się stało :(', err)
 
          trackError(err, window.location.href)
 
          throw err
        }
      },
      get,
      api
    )
 
const useAnyStore = create<SomeStoreType>()(
  reportException<SomeStoreType>((set) => ({
    // Stan początkowy oraz akcje.
  }))
)
`}</Code>
  <M>
    W przypadku <B>Zustand</B> musimy jawnie używać <B>middleware</B> dla
    każdego <B>store</B> - patrz linia <B>25</B>. Aby uniknąć duplikacji kodu
    możemy stworzyć fabrykę, która zajmie się tworzeniem <B>store</B>, który
    odrazu będzie miał podpięte <B>middleware</B>.
  </M>
  <Code mode="static" lang="ts">{`
const createReportableStore = <T>(storeCreator: StateCreator<T>) =>
  create<T>()(reportException<T>(storeCreator))
 
const useMyReportableStore = createReportableStore<SomeStoreType>((set) => ({
  // Dowolny stan oraz akcje.
}))
`}</Code>
  <M>
    To samo podejście możemy wykorzystać w przypadku <B>devtools</B>, które
    widzieliśmy wczesniej.{" "}
  </M>
  <Hint hasBg>
    Przeczytaj{" "}
    <A outside href="/articles/testing/mocking-up-with-factories/">
      artykuł o mockowaniu za pomocą fabryk
    </A>
    , aby dowiedzieć się więcej o tym koncepcie.{" "}
  </Hint>
</Section>

<Section>
  <XL>Persystencja danych w Redux toolkit</XL>
  <M>
    Aby zapisać zawartość <B>store</B> do <B>local/session</B> storage musimy
    dodać bibliotekę. Instalujemy paczkę:{" "}
    <B>npm i --legacy-peer-deps --save redux-persist</B>. Kolejne <B>+3kB</B>.
  </M>
  <Code mode="static" lang="ts">{`
import { configureStore } from "@reduxjs/toolkit"
import storage from "redux-persist/lib/storage"
import { persistReducer, persistStore } from "redux-persist"
import * as reducers from "./reducers"
 
const persistConfig = {
  key: 'root',
  storage,
}
 
const persistedReducer = persistReducer(persistConfig, reducers)
 
export const store = configureStore({
  reducer: persistedReducer,
})
 
export const persistor = persistStore(store)`}</Code>
  <M>
    Teraz w główym pliku aplikacji <B>app.tsx</B> musimy dodać <B>wrapper</B> -{" "}
    <B>PersistGate</B>.
  </M>
  <Code mode="static" lang="tsx">{`
import { persistor, store } from "./store"
import { PersistGate } from "redux-persist/integration/react"
 
root.render(
    <Provider store={store}>
      <PersistGate loading={null} persistor={persistor}>
        <App />
      </PersistGate>
    </Provider>
)`}</Code>
</Section>

<Section>
  <XL>Persystencja danych w Zustand</XL>
  <Code mode="static" lang="ts">{`
  import { create } from "zustand"
import { persist, createJSONStorage } from "zustand/middleware"
 
export const useAnyStore = create(
  persist(
    (set, get) => ({
      bears: 0,
    }),
    {
      // Atrybut "name" musi być unikalny - pod nim będą.
      name: 'food-storage',
      // Opcjonalne - domyślnie używane jest "local storage".
      storage: createJSONStorage(() => sessionStorage)
    }
  )
)`}</Code>
  <Hint hasBg>
    Jeżeli chesz dowiedzieć się więcej o pracy z <B>local/session</B> storage w
    łatwy sposób, to zapraszam do artykułu:{" "}
    <A
      outside
      href="/articles/patterns/working-with-local-storage-vs-session-storage/"
    >
      Working with local storage vs session storage
    </A>
    .
  </Hint>
</Section>

<Section>
  <XL>Memoizacja i selektory w Redux toolkit</XL>
  <M>
    <B>Selektory</B> to funkcje, które mają za zadanie sprawdzić czy
    rzeczywiście zmieniła się wartość lub referencja dla danego fragmentu{" "}
    <B>store</B>. Wtedy możemy tę wartość zwrócić lub wykonać dodatkowe operacje
    - mapowanie do innego formatu danych. Wynik selektorów może być{" "}
    <B>zapamiętany</B> dla konkretnych argumentów. Jeżeli nie uległy zmianie,
    zostanie zwrócona stara wartość - dzięki temu <B>React</B> nie wykona
    re-renderu.
  </M>
  <Code mode="static" lang="ts">{`
  import { createSelector } from "reselect"
  
const getUsers = state => state.users
 
export const getMemoizedUsers = createSelector(
  [getUsers],
  users => users.filter(user => user.active)
)`}</Code>
  <M>A teraz kod komponentu: </M>
  <Code mode="static" lang="tsx">{`import { useSelector } from "react-redux"
import { getMemoizedUsers } from "./selectors"
 
const UserList = () => {
  const memoizedUsers = useSelector(getMemoizedUsers)
}
`}</Code>
  <M>
    Nie wiem, czy zwróciliście uwagę, ale zainstalowaliśmy kolejną bibliotekę -{" "}
    <B>reselect</B>, która zwiększa rozmiar naszej aplikacji o kolejne{" "}
    <B>1.3kB</B>.
  </M>
</Section>

<Section>
  <XL>Memoizacja i selektory w Zustand</XL>
  <M>
    Wystarczy wykorzystać stworzony <B>store</B> w ten sposób:{" "}
  </M>
  <Code mode="static" lang="ts">{`
const useMemoizedUsers = 
  useUsersStore((state) => state.users.filter(user => user.active))
`}</Code>
  <M>A w komponencie robimy tak: </M>
  <Code mode="static" lang="tsx">{`
import { useMemoizedUsers } from "usersStore"
  
const UserList = () => {
  const memoizedUsers = useMemoizedUsers()
}
`}</Code>
  <M>
    Dodatkowo możemy to jeszcze usprawnić tworząc mechanizm do tworzenia{" "}
    <B>selektorów</B> w sposób automatyczny. Nie jest to temat tego artykułu,
    więc wspominam tylko o tym. Więcej o tym frykasie możesz znaleźć pod{" "}
    <A
      href="https://codesandbox.io/s/zustand-auto-generate-selectors-forked-rl8v5e?file=/src/App.tsx:91-126"
      outside
    >
      tym codesandboxem
    </A>
    . Podobny mechanizm możemy stworzyć dla <B>Reduxa</B> - żeby nie było...
  </M>
  <Code mode="static" lang="ts">{`
// Tak wywołamy automatycznie wygenerowane selektory
// w komponentach.
const bears = useStore.use.bears();
const increment = useStore.use.increment();
 `}</Code>
</Section>

<Section>
  <XL>Testowanie z Redux toolkit</XL>
  <M>Najpierw musimy zacząć od czegoś, co pozwoli nam zamockować <B>store</B>. Poniższa funkcja <B>createStore</B> pozwoli nam go stworzyć oraz da możliwość nadpisania jego wartośc per test. Natomist funkcja <B>renderWithStore</B> podłączy nam dowolny komponent do <B>Reduxa</B>.</M>
<Code mode="static" lang="ts">{`import React, { PropsWithChildren } from "react"
import type { PreloadedState } from "@reduxjs/toolkit"
import { configureStore } from "@reduxjs/toolkit"
import { render } from "@testing-library/react"
import { Provider } from "react-redux"
 
import type { AppState } from "store"
import reducer from "store/reducers"
 
export const createStore = (preloadedState: PreloadedState<AppState>) => {
  return configureStore({
    reducer,
    preloadedState,
  })
}
 
export const renderWithStore = (
  component: React.ReactElement,
  state: Partial<AppState>,
  store = createTestStore(state)
) => {
  const Wrapper = ({ children }: PropsWithChildren<{}>) => {
    return <Provider store={store}>{children}</Provider>
  }
 
  return { store, ...render(component, { wrapper: Wrapper }) }
}
`}</Code>
<M>Teraz załóżmy, że chcemy przetestować jak działa nasz komponent <B>PostsList</B>, który korzysta wewnątrz z <B>useAppSelector</B> i <B>useAppDispatch</B> do wyświetlenia listy postów i do dodania postu. </M>
<Code mode="static" lang="tsx">{`
import { screen } from "@testing-library/react"
import { renderWithStore } from "store/fixtures"
import { PostsList } from "./PostsList"
 
describe("Posts works when: ", () => {
  it("renders posts and adds post", () => {
    const { store } = renderWithStore(<PostsList />, {
      posts: {
        posts: [{ title: 'My post' }],
        loading: false,
        error: '',
      },
    })
      
    const dispatchSpy = jest.spyOn(store, "dispatch")
 
    fireEvent.click(screen.getByText("Add post"))
 
    expect(dispatchSpy).toHaveBeenCalledTimes(1)
  })
})
`}</Code>
<Hint hasBg> Jeżeli jesteście ciekawi tematów związanych z testowaniem, to zapraszam do lektury kursu <A href="/courses/react-testing-spellbook/" outside>React testing spellbook</A>.</Hint>

</Section>

<Section>
  <XL>Testowanie w Zustand</XL>
  <M>
    Po każdym teście musimy mieć mechanizm do przywracania początkowego stanu. W
    innym przypadku, gdy go nie będzie, w kolejnych testach będziemy mieć
    wcześniej ustawiony stan - co jest niebezpieczne dla stabilności testów.
  </M>
  <Code
    mode="static"
    lang="ts"
  >{`import { renderHook, act } from "@testing-library/react"
import type { StoreApi, UseBoundStore } from "zustand"
 
const storeFixture = <T>(
  useStore: UseBoundStore<StoreApi<T>>,
  defaultState?: T
) => {
  const initialState = useStore.getState()
 
  if (defaultState) {
    // Wykorzystaliśmy "act" z "react-testing-library".
    // Funkcja "create" z "zustand" zwraca hook, więc 
    // każdą zmiane stanu podczas testowania
    // musimy zrobić z "act" - w innym razie będą errory.
    act(() => {
      useStore.setState(defaultState)
    })
  }
 
  const restore = (): void => {
    act(() => {
      useStore.setState(initialState);
    })
  }
 
  const { result } = renderHook(() => useStore())
 
  return {
    restore,
    result,
  }
}
 
export { storeFixture }
`}</Code>
  <M>A teraz przykład użycia przy testowaniu komponentu: </M>
  <Code mode="static" lang="tsx">{`
import { screen, render, fireEvent } from '@testing-library/react'
import { PostsList } from './PostsList'
import { storeFixture } from '@Fixtures'
import { usePostsStore } from '@Store/usePostsStore'
 
describe('Posts works when: ', () => {
  it('renders posts and adds post', () => {
    // Tak ustawiamy początkową wartość dla "store".
    // Możemy to pominąć, wtedy przyjmie on wartość ustawioną
    // w implementacji.
    const { restore, result } = storeFixture(usePostsStore, {
      posts: [{ title: 'My post' }],
      loading: false,
      error: '',
    })
 
    const spy = jest.spyOn(result, 'addPost')
 
    render(<PostsList />)
 
    fireEvent.click(screen.getByText('Add post'))
 
    expect(spy).toHaveBeenCalledTimes(1)
    // To jest bardzo ważne! Musimy pamiętać o użyciu 
    // "restore", które ustawi stan na początkowy.
    restore()
  })
})
`}</Code>
</Section>

<Section>
  <XL>Zarządzanie stanem w Redux toolkit</XL>
  <M>
    <B>Redux toolkit</B> wykorzystuje <B>Immer.js</B>, abyśmy mogli zmieniać
    stan w łatwy i przyjemny sposób.
  </M>
  <Code mode="static" lang="ts">{`
// Tak było bez "Redux toolkit" i "Immer.js".
state = {
  ...state.user,
  ...payload
}
// Tak z "Redux toolkit".
state.user = payload
  `}</Code>
  <M>
    Czasami jednak chcemy zrestować stan lub go częściowo podmienić. Niestety{" "}
    <B>Redux toolkit</B> na to nie pozwala. Nie można wyłączyć zachowania{" "}
    <B>Immer.js</B>. Jeżeli chcemy uzyskać ten efekt, to nie obejdzie się bez
    jakiegoś dodatkowego mechanizmu, który musimy sami napisać.{" "}
  </M>
  <Code mode="static" lang="ts">{`
const initialState = {
  user: null,
  loading: false,
  error: ""
}
 
state.user = initialState.user
state.loading = initialState.loading
state.error = initialState.error
// itd...
 
// Można też tak.
Object.keys(state).forEach((key) => {
  state[key] = initialState[key]
})
 
// Spotyka się też coś takiego.
// Pod value kryje się cały stan.
// Dzięki temu póżniej możemy podmienić stan w całości.
state.value = {
  user: null,
  loading: false,
  error: ""
}
// Poźniej w jakiejś akcji.
state.value = initialState
  `}</Code>
</Section>

<Section>
  <XL>Zarządzanie stanem w Zustand</XL>
  <M>
    W <B>Zustand</B> mamy wybór. Możemy podmienić stan całkowicie lub nowy stan
    scalić z obecnym.{" "}
  </M>
  <Code mode="static" lang="ts">{`
// To zmerguje aktualny stan z podaną flagą.
set({ loading: true  })
// To podmieni aktualny stan całkowicie.
set(initialState, true)
  `}</Code>
  <M>
    A jak dorzucić <B>Immera</B>? Jeżeli jest taka potrzeba, to wystarczy użyć
    następującego <B>middleware</B>.
  </M>
  <Code mode="static" lang="ts">{`
  import { create } from 'zustand'
import { immer } from 'zustand/middleware/immer'
 
type State = {
  count: number
}
 
type Actions = {
  increment: (value: number) => void
}
 
const useCountStore = create(
  immer<State & Actions>((set) => ({
    count: 0,
    increment: (value) =>
      set((state) => {
        state.count += value
      })
  }))
)`}</Code>
</Section>

<Section>
  <XL>Praca z akcjami w Redux toolkit</XL>
  <M>
    Czasami chcemy wywołać akcję poza ekosystemem <B>Reacta</B>. W{" "}
    <B>Redux toolkit</B> musimy zaimportować cały <B>store</B> oraz akcję i
    wywołać <B>dispatch</B>.
  </M>
  <Code mode="static" lang="ts">
    {`
import { store } from '/path/to/createdStore'
import { testAction } from '/path/to/action'
 
store.dispatch(testAction('content'))`}
  </Code>
</Section>

<Section>
  <XL>Praca z akcjami w Zustand</XL>
  <M>
    Tu wystarczy deklaracja <B>akcji</B>, jej <B>import</B> oraz{" "}
    <B>wywołanie</B>.
  </M>
  <Code mode="static" lang="ts">{`
const testAction = (): void => {
  useSomeStore.setState({ someData: null })
}
 
import { testAction } from 'path/to/action'
 
testAction()
`}</Code>
</Section>

<Section>
  <XL>Odczyt stanu w Redux toolkit oraz Zustand</XL>
  <M>
    Aby nasłuchiwać na zmiany stanu zarówno w <B>Redux toolkit</B> jak i{" "}
    <B>Zustand</B>, możemy skorzystać z następującego API:{" "}
  </M>
  <Code mode="static" lang="ts">{`
// Dla Reduxa
store.subscribe(() => {
  // Możemy coś zrobić.
})
// Dla Zustanda.
useSomeStore.subscribe(() => {
  // Możemy coś zrobić.
})
  `}</Code>
  <M>Odczyt aktualnego stanu wygląda podobnie: </M>
  <Code mode="static" lang="ts">{`
    // Dla Reduxa
store.getState()
// Dla Zustanda.
useSomeStore.getState()`}</Code>
  <M>
    Nie widać różnicy w API, ale jest diametralna różnica w sposobie działania.{" "}
    <B>Redux</B> będzie wywoływał callback <B>subscribe</B> przy wywołaniu
    jakiejkolwiek zmiany stanu, natomiast <B>Zustand</B> tylko wtedy, gdy zmieni
    się ten jeden, konkretny <B>store</B>.
  </M>
  <M>
    Podobnie dla <B>getState</B>. <B>Redux</B> zwróci wszystko (cały stan
    aplikacji), a <B>Zustand</B> tylko <B>store</B>, do którego się odnosimy
    (stan funkcjonalności).
  </M>
</Section>

<Section>
  <XL>Code splitting i lazy loading w Redux toolkit</XL>
  <M>
    <B>Code splitting</B> oraz <B>lazy loading</B> to dwie popularne techniki,
    które mają zredukować czas poświecony na "pierwsze" załadowanie dowolnej
    aplikacji. Jaki jest sens ładować kod dla funkcjonalności administratora,
    jeżeli użytkownik nim nie jest?{" "}
  </M>
  <M>
    W <B>Redux toolkit</B> na samym początku musimy mieć mechanizm do podmiany
    głównego <B>reducera</B> - to już mamy w bibliotece.
  </M>
  <Code mode="static" lang="ts">{`
// Nowy reducer.
const newRootReducer = combineReducers({
  existingSlice: existingSliceReducer,
  newSlice: newSliceReducer,
});
// Podmieniamy go z aktualnym.
store.replaceReducer(newRootReducer);
`}</Code>
  <M>
    Teraz musimy mieć możliwość dodania nowego <B>slice</B>.
  </M>
  <Code mode="static" lang="ts">{`
import { createStore } from 'redux';
 
// To są reducery, które muszą być na stracie aplikacji.
// Są wymagane do jej działania
const staticReducers = {
  users: usersReducer,
  posts: postsReducer,
};
 
export default function configureStore(initialState) {
  const store = createStore(createReducer(), initialState);
 
  // Słownik do trzymania dynamicznie dodanych reducerów.
  store.asyncReducers = {};
 
  // Dodajemy nowy reducer i scalamy go z obecnymi.
  store.injectReducer = (key, asyncReducer) => {
    store.asyncReducers[key] = asyncReducer;
    store.replaceReducer(createReducer(store.asyncReducers));
  };
 
  return store;
}
 
function createReducer(asyncReducers) {
  return combineReducers({
    ...staticReducers,
    ...asyncReducers,
  });
}
`}</Code>
  <M>Teraz możemy wywołać w dowolnym miejscu: </M>
  <Code mode="static" lang="ts">{`
import { store } from 'store'
import { createSlice } from 'redux-toolkit'
 
store.injectReducer('reducerek', createSlice(
  // Konfiguracja slice.
).reducer)
`}</Code>
  <Hint hasBg>
    Więcej na ten temat możesz znaleźć w{" "}
    <A href="https://redux.js.org/usage/code-splitting" outside>
      dokumentacji
    </A>
    .
  </Hint>
</Section>

<Section>
  <XL>Code splitting i lazy loading w Zustand</XL>
  <M>
    Ze względu na modułową naturę, <B>code splitting</B> i <B>lazy loading</B>{" "}
    mamy praktycznie <B>out of the box</B> czy <B>plug and play</B>. Dzięki temu
    zarówno kod <B>React</B> jak i <B>Zustand</B> będzie znajdował się w jednym
    pliku, i możemy go w całości oddzielić od głównego, niezbędnego do działania
    aplikacji pliku <B>index.js</B>, który będzie ładowany na początku.
    Dodatkowo jest to przewidywalne w zachowaniu.
  </M>
  <Code mode="static" lang="tsx">
    {`// Plik RegisterForm.tsx
 
import { useRegisterStore } from '@store/register'
 
const RegisterForm = () => {
  const { key, form, setField, submit, error } = useRegisterStore()
 
  // Potężna ilość kodu - załóżmy, że 300 linijek
}
 
export default RegisterForm;
 
// Plik RegisterView.tsx
 
import dynamic from 'next/dynamic'
 
// Ten kod będzie ładowany leniwie i będzie miał oddzielny plik!
const RegisterForm = dynamic(() => import('./RegisterForm'))
 
const RegisterView = () => <RegisterForm />
`}
  </Code>
</Section>

<Section>
  <XL>Analizujemy runtime performance</XL>
  <M>
    W <B>Redux toolkit</B> korzystamy z obiektu <B>TYP_AKCJI: FUNKCJA</B>, co
    wygląda elegancko, ale w dalszym ciągu wywołujemy każdy <B>reducer</B> przy
    każdej akcji.
  </M>
  <Code mode="static" lang="ts">{`
const firstSlice = createSlice({
  name: "firstSlice",
  {},
  reducers: {
    log1: () => {
      console.log('firstSliceLog')
    }
  },
});
 
const secondSlice = createSlice({
  name: "secondSlice",
  {},
  reducers: {
    log1: () => {
      console.log('secondSliceLog')
    }
  },
});
 
store.dispatch(firstSlice.actions.log());
// Liczba porównań to 2 = bo mamy 2x slice.reducer.
store.dispatch(secondSlice.actions.log());
// Liczba porównań to aktualnie 4.
// Wcześniej 2, a teraz 2 kolejne.
  `}</Code>
  <M>
    W <B>Zustand</B> każdy <B>store</B> jest niezależny od siebie. Nie będzie
    zatem żadnych dodatkowych porównań.
  </M>
  <Code mode="static" lang="ts">{`
  const useFirstStore = create();
 
const firstStoreLog1 = () => {
  console.log('firstStoreLog');
};
 
const useSecondStore = create();
 
const secondStoreLog2 = () => {
  console.log('secondStoreLog');
};
 
firstStoreLog1();
secondStoreLog2();
// Tutaj nie ma żadnych, dodatkowych porównań.
  `}</Code>
  <M>
    Teraz w momencie gdy mamy 30 reducerów w aplikacji, przy <B>Redux</B>{" "}
    wywołamy aż 29 dodatkowych czynności dla każdej wywołanej akcji. Czy jest to
    problem? Szczerze, to nie... Po prostu wspominam o tym. Sama operacja
    znajdowania akcji jest bardzo szybka, więc raczej nie ma się czym
    przejmować...
  </M>
</Section>

<Summary label="To w końcu Redux czy Zustand?">
  <M>
    Z każdym dniem zdaję sobie sprawę, że prościej znaczy lepiej. Twierdzę tak
    dlatego, że nad projektami pracują ludzie na różnym poziomie. <B>Redux</B>{" "}
    potrafi być naprawdę skomplikowany i bardzo łatwo się jest na nim zwyczajnie{" "}
    <B>połamać</B>. Sam koncept jest świetny, ale moim zdaniem <B>Zustand</B>{" "}
    realizuje go poprzez prostsze API i wprowadza nowe możliwości - więcej niż
    jeden <B>store</B>.{" "}
  </M>
  <M>
    {" "}
    <B>Zustand</B> rezygnuje również z konceptu <B>CQRS</B> (command query responsibility
    segregation), w którym odczyt danych jest odseparowany od sposobu wywołania na
    nich zmian - przez co znacznie zredukowany jest <B>coupling</B> i potencjalne
    refaktory będa prostsze, jak i samo utrzymanie kodu - przynajmniej w teorii.
  </M>
  <M>
    W praktyce jednak skomplikowanie <B>Reduxa</B> powoduje powstawanie
    totalnego makaronu i widziałem to już w wielu projektach. Przez co zalety i
    koncepty, które wprowadza, przestają być "game changerem", a są tylko
    problemem - bo ciężko jest je zrozumieć.{" "}
  </M>
  <M>
    Nie zniechęcam Cię do <B>Reduxa</B>, lecz pragnę podkreślić pytanie. Czy
    naprawdę potrzebujesz <B>CQRS</B> na <B>frontendzie</B> i czy na prawdę
    dodatkowe skomplikowanie, które wprowadza <B>Redux</B> cokolwiek Ci daje?
  </M>
  <M>
    Jak pewnie widzieliście, różnic pomiędzy omawianymi technologiami jest
    wiele. Decyzję zostawiam Wam, Drodzy Czytelnicy. Przedstawiam kilka
    argumentów dlaczego ja stosuje <B>Zustanda</B>, zamiast <B>Reduxa</B>:{" "}
  </M>
  <L>
    <Li>Mniejszy rozmiar paczki i kodu wynikowego funkcjonalności</Li>
    <Li>Modułowość</Li>
    <Li>Te same możliwości co Redux (bez CQRS i z wieloma storami)</Li>
    <Li>Mniej kodu potrzebnego do napisania</Li>
    <Li>
      Kod jest czytelniejszy i łatwiejszy do zrozumienia dla początkujących
    </Li>
    <Li>Code splitting jest łatwo osiągnąć</Li>
    <Li>Devtools takie jak w Redux</Li>
    <Li>Brak wrappera (StoreProvider)</Li>
  </L>
</Summary>
